<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Théo Moins, Julyan Arbel, Stéphane Girard, Anne Dutfoy" />


<title>On the use of a local R-hat to improve MCMC convergence diagnostic</title>

<script src="Simulations_files/header-attrs-2.11/header-attrs.js"></script>
<script src="Simulations_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Simulations_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="Simulations_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Simulations_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Simulations_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="Simulations_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="Simulations_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="Simulations_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="Simulations_files/navigation-1.1/tabsets.js"></script>
<link href="Simulations_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="Simulations_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">



<h1 class="title toc-ignore">On the use of a local R-hat to improve MCMC convergence diagnostic</h1>
<h4 class="author">Théo Moins, Julyan Arbel, Stéphane Girard, Anne Dutfoy</h4>

</div>


<pre class="r"><code>library(&quot;EnvStats&quot;)
library(&#39;jmuOutlier&#39;)
library(&quot;ggplot2&quot;)
library(&quot;rstan&quot;)

devtools::load_all()

source(paste(r_folder, &quot;import/monitornew.R&quot;, sep=&quot;&quot;))
source(paste(r_folder, &quot;import/r_star_monitor.R&quot;, sep=&quot;&quot;))

reps &lt;- 500</code></pre>
<p>This notebook is a supplementary material of the paper “On the use of a local <span class="math inline">\(\hat{R}\)</span> to improve MCMC convergence diagnostic” (<a href="https://hal.inria.fr/hal-03600407">link</a>). It illustrates the use of a localized version of the Gelman–Rubin diagnostic (commonly named <span class="math inline">\(\hat{R}\)</span>) on various examples. This local version <span class="math inline">\(\hat{R}(x)\)</span> has a population counterpart which can be written <span class="math display">\[\begin{equation}
    \label{eq:R_theorique}
    R(x) = \sqrt{\frac{W(x)+B(x)}{W(x)}} = \sqrt{1 + \frac{\sum_{j=1}^m\sum_{k=j+1}^m \left(F_j(x)-F_k(x)\right)^2}{m\sum_{j=1}^m F_j(x)(1-F_j(x))}}.
\end{equation}\]</span> In addition to the <span class="math inline">\(\hat{R}(x)\)</span> curves, we suggest to use <span class="math inline">\(R_\infty = \sup_{x \in\mathbb{R}} R(x)\)</span> as a scalar summary.</p>
<p>This notebook includes most of the examples used in the article plus others, showing how the figures were generated. Section 1 concerns some toy examples (Section 2.5 in the paper), Section 2 the multivariate extension (Section 3 in the paper), and Section 3 the applications to Bayesian inference (Section 4 in the paper).</p>
<p>For reproducibility, the code that is used and the corresponding markdown file is also available online (<a href="https://github.com/TheoMoins/localrhat" class="uri">https://github.com/TheoMoins/localrhat</a>).</p>
<div id="known-distributions-on-the-chains" class="section level1" number="1">
<h1 number="1"><span class="header-section-number">1</span> Known distributions on the chains</h1>
<div id="threshold-estimation" class="section level2" number="1.1">
<h2 number="1.1"><span class="header-section-number">1.1</span> Threshold estimation</h2>
<p>We start by illustrate the choice of threshold for <span class="math inline">\(\hat{R}_\infty\)</span> depending on the number of chains. We focus on the case where all the distributions are the same, to verify the behavior in the null hypothesis, and estimate the type I error at <span class="math inline">\(5\%\)</span>. This value will be used as a threshold to determine whether or not the chains follows the same distribution (i.e. convergence is reached). For each example we keep a constant number of i.i.d samples (<span class="math inline">\(nm=400\)</span>)</p>
<p>For <span class="math inline">\(m=2\)</span>, <span class="math inline">\(1.01\)</span> seems to be an adapted threshold:</p>
<pre class="r"><code>sigma &lt;- 1
alpha &lt;- 0.8
eta &lt;- 1

M &lt;- 2
N &lt;- 200

uniform_rdists &lt;- c((function(n) runif(n, -sigma, sigma)),
                    (function(n) runif(n, -sigma, sigma)))

pareto_rdists &lt;- c((function(n) rpareto(n, location = eta, shape = alpha)),
                   (function(n) rpareto(n, location = eta, shape = alpha)))

colors_same &lt;- c(rgb(0.55, 0, 0.4, 0.8), rgb(0.4, 0, 0.7, 0.8), rgb(0.5, 0, 0.5, 0.9))

R_matrix_same_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c(&quot;Uniform&quot;),
                                    reps = reps)

R_matrix_same_par &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c(&quot;Pareto&quot;),
                                   reps = reps)

R_matrix_same_unif_par &lt;- cbind(R_matrix_same_unif, R_matrix_same_par)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          threshold = 1.01001, xlabels = xlabels, bin_size = 0.0020,
          lim_y_axis = 200, vaxis_pos = 0.9985, plot_legend = F)</code></pre>
<p><img src="Simulations_files/figure-html/same_uniform_hists1-1.png" width="1152" /></p>
<p>For <span class="math inline">\(m=4\)</span>, <span class="math inline">\(1.01\)</span> may be too strong and <span class="math inline">\(1.02\)</span> seems more reasonable:</p>
<pre class="r"><code>M &lt;- 4
N &lt;- 100

R_matrix_same_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c(&quot;Uniform&quot;),
                                    reps = reps)

R_matrix_same_par &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c(&quot;Pareto&quot;),
                                   reps = reps)

R_matrix_same_unif_par &lt;- cbind(R_matrix_same_unif, R_matrix_same_par)


xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          xlabels = xlabels, bin_size = 0.002, threshold = 1.02,
          lim_y_axis = 200, vaxis_pos = 0.9985, plot_legend = F)</code></pre>
<p><img src="Simulations_files/figure-html/same_uniform_hists2-1.png" width="1152" /></p>
<p>This increases persists as the number of chains increase, typically <span class="math inline">\(1.03\)</span> should be considered when <span class="math inline">\(m=8\)</span>:</p>
<pre class="r"><code>M &lt;- 8
N &lt;- 50

R_matrix_same_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c(&quot;Uniform&quot;),
                                    reps = reps)

R_matrix_same_par &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c(&quot;Pareto&quot;),
                                   reps = reps)

R_matrix_same_unif_par &lt;- cbind(R_matrix_same_unif, R_matrix_same_par)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          threshold = 1.03, xlabels = xlabels, bin_size = 0.002,
          lim_y_axis = 200, vaxis_pos = 0.9985)</code></pre>
<p><img src="Simulations_files/figure-html/same_uniform_hists3-1.png" width="1152" /></p>
</div>
<div id="counter-examples-for-hatr" class="section level2" number="1.2">
<h2 number="1.2"><span class="header-section-number">1.2</span> Counter examples for <span class="math inline">\(\hat{R}\)</span></h2>
<p>Then, we consider two cases where <span class="math inline">\(\hat{R}\)</span> is not able to detect a convergence failure, and a then some examples where the improvement rank-<span class="math inline">\(\hat{R}\)</span> also fails.</p>
<div id="chains-with-same-mean-and-different-variances-uniform-distribution" class="section level3" number="1.2.1">
<h3 number="1.2.1"><span class="header-section-number">1.2.1</span> Chains with same mean and different variances: Uniform distribution</h3>
<p>As a first example we consider <span class="math inline">\(m\)</span> chains following centered uniform distributions, with the last having a different support than the other: <span class="math display">\[\begin{align*}
  F_1(x) &amp;= \cdots = F_{m-1}(x) =  \frac{x}{2\sigma} + \frac{1}{2}, \quad \forall x \in \left[-\sigma; \sigma\right],\\
  \text{and}\quad F_m(x) &amp;=  \frac{x}{2\sigma_m} + \frac{1}{2}, \quad \forall x \in \left[-\sigma_m; \sigma_m\right].
\end{align*}\]</span></p>
<p>In such a case the expression of <span class="math inline">\(R(x)\)</span> is explicit (see Example 1 in Section 2.5) and can be compared to the estimator <span class="math inline">\(\hat{R}(x)\)</span>. To illustrate we choose <span class="math inline">\(m=4\)</span> chains, <span class="math inline">\(\sigma = 3/4\)</span> and <span class="math inline">\(\sigma_m = 1\)</span>:</p>
<pre class="r"><code>sigma &lt;- 3/4
sigmaM &lt;- 1
M &lt;- 4
N &lt;- 200

uniform_dists &lt;- c(rep(c((function(q) punif(q, -sigma, sigma))), M-1),
                   (function(q) punif(q, -sigmaM, sigmaM)))

theoretical_r_values &lt;- r_dist_values(npoints = N, xlim = c(-sigmaM, sigmaM),
                                      dists = uniform_dists)

uniform_rdists &lt;- c((function(n) runif(n, -sigma, sigma)),
                    (function(n) runif(n, -sigmaM, sigmaM)))

chains = gen_chains(M, N, uniform_rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.0715
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.071543</code></pre>
<pre class="r"><code>simulated_rhat = all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08)
plot_local_r(chains, simulated_rhat, theoretical_r_values, col=c(colors[3], colors[2]),
             xlabels = xlabels, plot_legend = FALSE,
             xlim = c(-1,1), ylim=c(1,1.09), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/uniform_r_x2-1.png" width="1152" /></p>
<p>We can see that <span class="math inline">\(\hat{R}(x)\)</span> (in violet) neither overestimate nor underestimate <span class="math inline">\(R(x)\)</span>, which makes it reasonable to estimate the population value.</p>
<p>We replicate the experiment 500 times and study the histogram of replications of different versions of <span class="math inline">\(\hat{R}\)</span>:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;,
             &quot;Rank-R-hat&quot;,
             &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08, 1.1)

plot_hist(R_matrix_unif, colors = r_colors, xlabels = xlabels,
          bin_size = 0.005, lim_y_axis = reps, plot_legend = F)</code></pre>
<p><img src="Simulations_files/figure-html/uniform_hist-1.png" width="1152" /></p>
<p>As constructed initially by Vehtari et al. (2021), this example fool the original <span class="math inline">\(\hat{R}\)</span>. The rank version as well as <span class="math inline">\(\hat{R}_\infty\)</span> is on the contrary robust in this case.</p>
</div>
<div id="chains-with-heavy-tails-and-different-locations-pareto-distribution" class="section level3" number="1.2.2">
<h3 number="1.2.2"><span class="header-section-number">1.2.2</span> Chains with heavy-tails and different locations: Pareto distribution</h3>
<p>Similarly, we check the second counter-example that fool the original <span class="math inline">\(\hat{R}\)</span>: chains with heavy-tails and different locations. To do so we consider Pareto distributions on the chains: <span class="math display">\[\begin{align*}
    F_1(x) &amp;= \cdots = F_{m-1}(x) = 1 - \left({x}/{\eta}\right)^{-\alpha},
    \quad \forall x \in [\eta, +\infty),\\
    \text{and}\quad F_m(x) &amp;=  1 - \left({x}/{\eta_m}\right)^{-\alpha},
    \quad \forall x \in [\eta_m, +\infty).
\end{align*}\]</span></p>
<p>As an example, we choose <span class="math inline">\(\alpha = 0.8 \leq 1\)</span> to ensure infinite moments and <span class="math inline">\((\eta, \eta_m) = (1, 1.5)\)</span>:</p>
<pre class="r"><code>eta &lt;- 1
etaM &lt;- 1.5
alpha &lt;- 0.8
M &lt;- 4

pareto_dists &lt;- c(rep(c((function(q) ppareto(q, location = eta, shape = alpha))), M-1),
                  (function(q) ppareto(q, location = etaM, shape = alpha)))

theoretical_r_values &lt;- r_dist_values(npoints = 1000, xlim = c(-eta, eta*8),
                                      dists = pareto_dists)

pareto_rdists &lt;- c((function(n) rpareto(n, location = eta, shape = alpha)),
                   (function(n) rpareto(n, location = etaM, shape = alpha)))

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08)
chains &lt;- gen_chains(M, N, pareto_rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.0408
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.040772</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

plot_local_r(chains, simulated_rhat, theoretical_r_values,
             plot_legend = FALSE, col=c(colors[3], colors[2]),
             xlabels = xlabels, xlim = c(1,8), ylim=c(1,1.09), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/pareto_r_x2-1.png" width="1152" /></p>
<p>The same observations as for the previous example can be done here: <span class="math inline">\(\hat{R}_\infty\)</span> is a reasonable quantity to estimate <span class="math inline">\(R_\infty\)</span>. We can verify the behavior on replications:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_pareto &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08)
plot_hist(R_matrix_pareto, colors = r_colors, xlabels = xlabels,
          plot_legend = FALSE, bin_size = 0.005, lim_y_axis = 500)</code></pre>
<p><img src="Simulations_files/figure-html/pareto_hists-1.png" width="1152" /></p>
</div>
</div>
<div id="counter-examples-for-rank-hatr" class="section level2" number="1.3">
<h2 number="1.3"><span class="header-section-number">1.3</span> Counter examples for rank-<span class="math inline">\(\hat{R}\)</span></h2>
<p>In this part, We will see 3 cases where rank-<span class="math inline">\(\hat{R}\)</span> doesn’t manage to detect the convergence issue. These cases correspond to chains with different type of distributions, but with same mean and mean over the median. See Appendix A for details about the construction of such examples.</p>
<div id="uniform-and-laplace-distributions" class="section level3" number="1.3.1">
<h3 number="1.3.1"><span class="header-section-number">1.3.1</span> Uniform and Laplace distributions</h3>
<p>We start by an example where the population version can be computed explicitly: if one chain is uniformly distributed <span class="math inline">\(\mathcal{U}(-2\sigma, 2\sigma)\)</span> and another one from a Laplace distribution <span class="math inline">\(\mathcal{L}(0, \sigma)\)</span>, where <span class="math inline">\(\sigma&gt;0\)</span>, then calculations leads to <span class="math inline">\(R_\infty \approx 1.018\)</span>, which means convergence issue.</p>
<pre class="r"><code>sigma &lt;- 1/4
M &lt;- 2


dists &lt;- c((function(q) punif(q, -2*sigma, 2*sigma)),
           (function(q) plaplace(q, mean = 0, sd = sqrt(2)*sigma)))


theoretical_r_values &lt;- r_dist_values(npoints = 1000, xlim = c(-1.5, 1.5),
                                      dists = dists)


rdists &lt;- c((function(n) runif(n, -2*sigma, 2*sigma)),
            (function(n) rlaplace(n, mean = 0, sd = sqrt(2)*sigma)))


chains &lt;- gen_chains(M, N, rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0125
Local R-hat obtained:  1.0186
p-value:  0.003
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.018643</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.01, 1.02, 1.03)

plot_local_r(chains, simulated_rhat, theoretical_r_values, threshold = 1.01,
             xlabels = xlabels, col = c(colors[3], colors[2]),
             xlim = c(-1.5,1.5), ylim=c(1,1.03), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/laplace_uniform_x2-1.png" width="1152" /></p>
<p>Replications show that rank-<span class="math inline">\(\hat{R}\)</span> is fooled in the same way as <span class="math inline">\(\hat{R}\)</span> in this example:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_lapl_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)

plot_hist(R_matrix_lapl_unif, colors = r_colors, bin_size = 0.003,
          xlabels = xlabels, plot_legend = TRUE, threshold = 1.01,
          lim_y_axis = reps, vaxis_pos = 0.9985)</code></pre>
<p><img src="Simulations_files/figure-html/laplace_uniform_hists-1.png" width="1152" /></p>
</div>
<div id="uniform-and-normal-distributions" class="section level3" number="1.3.2">
<h3 number="1.3.2"><span class="header-section-number">1.3.2</span> Uniform and Normal distributions</h3>
<p>Similarly, others distributions are possible to build counter-examples. Consider <span class="math inline">\(m-1\)</span> normal chains <span class="math inline">\(\mathcal{N}\left(0, \frac{\pi}{2}\sigma^2\right)\)</span> and for the last one a uniform <span class="math inline">\(\mathcal{U}(-2\sigma, 2\sigma)\)</span>:</p>
<pre class="r"><code>sigma &lt;- 1/2
M &lt;- 2

dists &lt;- c((function(q) pnorm(q, mean = 0, sd = sqrt(0.5*pi)*sigma)),
           (function(q) punif(q, -2*sigma, 2*sigma)))

theoretical_r_values &lt;- r_dist_values(npoints = 1000, xlim = c(-2, 2),
                                      dists = dists)

rdists &lt;- c((function(n) rnorm(n, mean = 0, sd = sqrt(0.5*pi)*sigma)),
            (function(n) runif(n, -2*sigma, 2*sigma)))

chains &lt;- gen_chains(M, 2*N, rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0125
Local R-hat obtained:  1.0172
p-value:  0.00700000000000001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.017231</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.005, 1.01, 1.015, 1.02)

plot_local_r(chains, simulated_rhat, theoretical_r_values,
             xlabels = xlabels, col=c(colors[3], colors[2]), threshold = 1.01,
             xlim = c(-2,2), ylim=c(0.999,1.028), title =&quot;Gaussian/Uniform distributions&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/gaussian_uniform_x2-1.png" width="1152" /></p>
<p>Replications confirms that this construction are fooling the different versions of <span class="math inline">\(\hat{R}\)</span> except <span class="math inline">\(\hat{R}_\infty\)</span>:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_norm_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

xlabels = c(1, 1.01, 1.02, 1.03)
plot_hist(R_matrix_norm_unif, colors = r_colors, xlabels = xlabels,
          bin_size = 0.002, plot_legend = TRUE, threshold = 1.01,
          lim_y_axis = reps, vaxis_pos = 0.999)</code></pre>
<p><img src="Simulations_files/figure-html/gaussian_uniform_hists-1.png" width="1152" /></p>
</div>
<div id="uniform-and-exponential-distributions" class="section level3" number="1.3.3">
<h3 number="1.3.3"><span class="header-section-number">1.3.3</span> Uniform and Exponential distributions</h3>
<p>Finally, it is also possible to mix uniform distributions with exponential to build a counter-example for rank-<span class="math inline">\(\hat{R}\)</span>:</p>
<pre class="r"><code>M &lt;- 4
N &lt;- 200

min_unif &lt;- 1-2*log(2)
max_unif &lt;- 1+2*log(2)


dists &lt;- c(rep(c((function(q) pexp(q))), M-1),
           (function(q) punif(q, min_unif, max_unif)))

theoretical_r_values &lt;- r_dist_values(npoints = 500, xlim = c(-1, 6),
                                      dists = dists)

rdists &lt;- c((function(n) rexp(n)),
            (function(n) runif(n, min_unif, max_unif)))

chains &lt;- gen_chains(M, N, rdists)
rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.0617
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.061693</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08)
plot_local_r(chains, simulated_rhat, theoretical_r_values,
             xlabels = xlabels, col = c(colors[3], colors[2]),
             xlim = c(-1, 6), ylim=c(1,1.09), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/exp_uniform_x2-1.png" width="1152" /></p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_exp_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

plot_hist(R_matrix_exp_unif, colors = r_colors, bin_size = 0.007,
          lim_y_axis = 500, vaxis_pos = 0.997)</code></pre>
<p><img src="Simulations_files/figure-html/exp_uniform_hists-1.png" width="1152" /></p>
</div>
</div>
<div id="summary" class="section level2" number="1.4">
<h2 number="1.4"><span class="header-section-number">1.4</span> Summary</h2>
<p>The following boxplot summarizes the values of replicated <span class="math inline">\(\hat{R}\)</span>, rank-<span class="math inline">\(\hat{R}\)</span> and <span class="math inline">\(\hat{R}_\infty\)</span> on the different examples:</p>
<pre class="r"><code>data=data.frame(r_version, r_experiment,  r_values)

ggplot(data, aes(x=r_experiment, y=r_values, fill=r_version)) +
    geom_boxplot() +
    geom_hline(yintercept=1.01, linetype=&quot;dashed&quot;,
               color = &quot;black&quot;, size=0.5) +
    geom_hline(yintercept=1.02, linetype=&quot;dashed&quot;,
             color = &quot;green&quot;, size=0.5) +
    xlab(&quot;Experiments&quot;) + ylab(&quot;Values&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-8-1.png" width="1152" /></p>
</div>
</div>
<div id="multivariate-examples" class="section level1" number="2">
<h1 number="2"><span class="header-section-number">2</span> Multivariate examples</h1>
<p>In the multivariate case when <span class="math inline">\(\boldsymbol{\theta}=(\theta_1, \ldots, \theta_d)\in{\mathbb R}^d\)</span>, we suggest to apply <span class="math inline">\(\hat{R}\)</span> on a multivariate indicator variable <span class="math inline">\(I_{\boldsymbol{x}}^{(j)} = \mathbb{I}\{\theta_1^{(j)} \leq x_1, \ldots, \theta_d^{(j)} \leq x_d\}\)</span> for any <span class="math inline">\(\boldsymbol{x} = (x_1, \ldots, x_d) \in \mathbb{R}^d\)</span> in two steps:</p>
<pre><code>1. Compute the univariate $\hat{R}_{\infty,p}$ separately on each of the
coordinates $p\in\{1,\dots,d\}$.
2. If $\hat{R}_{\infty,p} &lt; 1.03$ for all $p\in\{1,\dots,d\}$, then all
margins are deemed to have converged and to be identically distributed.
Compute the multivariate $\hat{R}^{(\text{max})}_\infty$ to check the convergence of the
dependence structure in all dependence directions. If the number of dimension is too high,
compute a univarite $\hat{R}$ on the log-posterior.</code></pre>
<p>Thus we recommend to compute the multivariate version only in the case where all the univariate one doesn’t detect any convergence issue, this is why in the part we will focus only of cases where the margins are the same (for example uniform).</p>
<p>Additional experiments on different copulas using Open TURNS can be found here: (<a href="https://theomoins.github.io/localrhat/Simulations_ot.html" class="uri">https://theomoins.github.io/localrhat/Simulations_ot.html</a>)</p>
<pre class="r"><code>library(&quot;MASS&quot;) # For Multivariate Normal Distribution
library(&quot;stableGR&quot;) # For the R-hat version of Vats and Knudson (2018)
library(&quot;coda&quot;) # For an implementation of the multivariate R-hat of Brooks and Gelman (1998)
library(&quot;rWishart&quot;) # Wishart distribution
library(&quot;mcmc&quot;) # for logit data
library(&quot;ggridges&quot;)


brooks_multivariate_rhat &lt;- function(chaines){
  R_star_chains = aperm(chaines, c(1, 3, 2))
  return (r_hat_multivariate(R_star_chains, split_chains = F))
}

coda_multivariate_rhat &lt;- function(chaines){
  chaines_list = list()
  for (i in 1:dim(chaines)[3]){
    mcmc_ch &lt;- as.mcmc(chaines[,,i])
    chaines_list[[i]] &lt;- as.mcmc(chaines[,,i])
  }
  mcmc_chains = do.call(mcmc.list, list(chaines_list))
  return (gelman.diag(mcmc_chains)$mpsrf)
}</code></pre>
<div id="bivariate-case-normal-distributions" class="section level2" number="2.1">
<h2 number="2.1"><span class="header-section-number">2.1</span> Bivariate Case: Normal distributions</h2>
<p>In this section, we focus on two-dimensional parameters on which we aim at diagnose convergence of the corresponding MCMC (with any number of chains). This restriction allows to navigate easily between the positive dependence and the negative one of the two components.</p>
<p>In particular, we consider bivariate normal densities with zero means, and compare <span class="math inline">\(m-1\)</span> chains with identity covariance matrix, and one with non-zero off-diagonal elements <span class="math inline">\(\rho \in (-1,1)\)</span>.</p>
<p>We start by defining the function that will allows us to generate <span class="math inline">\(m\)</span> chains of size <span class="math inline">\(n\)</span> with this configuration :</p>
<pre class="r"><code>gen_bvnormal_chains &lt;- function(M, N, rho){
  sig_matrix &lt;- (1-rho) * diag(2) + matrix(rho, nrow=2, ncol=2)
  return (array(c(mvrnorm((M-1)*N, mu = rep(0, 2), Sigma = diag(2)),
                  mvrnorm(N, mu = rep(0, 2), Sigma = sig_matrix)), c(N,2,M)))
}</code></pre>
<p>As an example, we consider the case with <span class="math inline">\(m=2\)</span> chains of size <span class="math inline">\(n=200\)</span>, and <span class="math inline">\(\rho = 0.9\)</span> on the last chain. This choice of <span class="math inline">\(n\)</span> relatively small is due to the fact the elements in the chain are i.i.d here, so <span class="math inline">\(n\)</span> can be seen as an effective sample size for a given chain here.</p>
<pre class="r"><code>rho &lt;- 0.9
M &lt;- 2
N &lt;- 200

chains &lt;- gen_bvnormal_chains(M, N, rho)
rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0125
Local R-hat obtained:  1.0163
p-value:  0.01
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.016343</code></pre>
<p>We simulate 100 experiments, which result as 100 draws of the different <span class="math inline">\(\hat{R}\)</span>.</p>
<p>Histogram of the corresponding values of <span class="math inline">\(\hat{R}_\infty\)</span> and the multivariate <span class="math inline">\(\hat{R}\)</span> of Brooks and Gelman (1998) :</p>
<pre class="r"><code>rho &lt;- 0.9
M &lt;- 2
N &lt;- 200
reps &lt;- 100

r_functions = c(brooks_multivariate_rhat, rhat_infinity)
r_names = c(&quot;Brooks Multivariate R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors = c(colors[4], colors[3])

R_matrix = repetitions_R(chains_func = (function() gen_bvnormal_chains(M, N, rho)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08, 1.1, 1.12)
plot_hist(R_matrix, colors = r_colors, bin_size = 0.0045,
          lim_y_axis = 30, vaxis_pos = 0.995,
          xlabels = xlabels, plot_threshold = F)</code></pre>
<p><img src="Simulations_files/figure-html/bivariate_hists2-1.png" width="1152" /></p>
<div id="evolution-of-the-different-value-of-hatr-with-rho" class="section level3" number="2.1.1">
<h3 number="2.1.1"><span class="header-section-number">2.1.1</span> Evolution of the different value of <span class="math inline">\(\hat{R}\)</span> with <span class="math inline">\(\rho\)</span></h3>
<p>We consider the mean of 10 draws for the different versions of <span class="math inline">\(\hat{R}\)</span>, and plot the evolution of this value with <span class="math inline">\(\rho\)</span>:</p>
<pre class="r"><code>rho_list = c(-0.99, -0.9, -0.7, -0.5, -0.2, 0, 0.2, 0.5, 0.7, 0.9, 0.99)

d &lt;- 2
M &lt;- 2
N &lt;- 500
reps &lt;- 10


r_functions &lt;- c(rhat_infinity, brooks_multivariate_rhat)
r_names &lt;- c(&quot;R-hat-infinity&quot;, &quot;Brooks R-hat&quot;)

R_values &lt;- c()
x_val &lt;- c()
theoretical_R &lt;- c()


for (rho in rho_list){
  R_val_rho = repetitions_R(chains_func = (function() gen_bvnormal_chains(M, N, rho)),
                                    r_func = r_functions,
                                    r_names = r_names,
                                    reps = reps)
  R_values = rbind(R_values, R_val_rho)
  x_val = c(x_val, rep(rho, reps))

  sig_matrix &lt;- (1-rho) * diag(2) + matrix(rho, nrow=2, ncol=2)
  dists &lt;- c((function(q) mvtnorm::pmvnorm(upper = q, sigma = diag(2))[1]),
             (function(q) mvtnorm::pmvnorm(upper = q, sigma = sig_matrix)[1]))
  theoretical_R = c(theoretical_R, max_r_dist_bivariate(npoints = 200,
                                                        xlim = c(-3,3),
                                                        dists = dists))
}

par(mar=c(4,5.5,2,2))
plot(x=x_val, y=R_values[,1],
     col = c(colors[3]), pch = 19,
     xlab = expression(rho[&quot;m&quot;]), ylab = &quot;&quot;,
     xaxs=&quot;i&quot;, yaxs=&quot;i&quot;, bty = &quot;n&quot;,
     xaxt = &quot;n&quot;, yaxt = &quot;n&quot;,
     cex.lab = 2, cex.main = 2,
     lwd=9,
     xlim = c(-1.01, 1.02), ylim = c(0.999,1.105))
points(x=x_val, y=R_values[,2],
       col = c(colors[4]), pch = 19,
       lwd=9)
lines(rho_list, theoretical_R, type=&quot;l&quot;, col = colors[2], lwd=6, lty = 2)
points(x=rho_list, y=theoretical_R,
       col = c(colors[2]), pch = 19,
       lwd=9)
xlabels = c(1, 1.02, 1.04, 1.06, 1.08, 1.1)
ylabels = c(-1, -0.5, 0, 0.5, 1)
axis(1, labels=ylabels, at=ylabels, cex.axis=2, lwd=3, mgp = c(1,1,0))
axis(2, labels=xlabels, at=xlabels, cex.axis=2, mgp = c(1,0.5,0), lwd=2)
legend(x=0.6, y=1.14, col=c(colors[4], colors[3], colors[2]), pch=19,
       legend = c(expression(italic(hat(R))),
                  expression(italic(hat(R)[infinity])),
                  expression(italic(R[infinity]))), cex=2)</code></pre>
<p><img src="Simulations_files/figure-html/bivariate_rho-1.png" width="1152" /></p>
<p>Two remarks can be done here:</p>
<pre><code>1. First, $\hat{R}_\infty$ seems to be more sensitive to the difference in the
copula, and this phenomenon increases with $|\rho|$ which was expected.
2. The asymmetry can be link to the theoretical computations.
WARNING: The case $d=2$ is special: the orders on the two bounds PLOD and NLOD are
inverted compared to the asymptotic behavior, and that is why here we are
more sensitive when $\rho &lt; 0$ than when $\rho &gt;0$.</code></pre>
</div>
</div>
<div id="general-number-of-dimensions" class="section level2" number="2.2">
<h2 number="2.2"><span class="header-section-number">2.2</span> General number of dimensions</h2>
<div id="generation-of-a-covariance-matrix" class="section level3" number="2.2.1">
<h3 number="2.2.1"><span class="header-section-number">2.2.1</span> Generation of a covariance matrix</h3>
<p>In the general case, we still compare <span class="math inline">\(m-1\)</span> chains that follows a multivariate normal distribution with identity covariance matrix with one that has a given covariance matrix <span class="math inline">\(\Sigma\)</span>.</p>
<p>We generate <span class="math inline">\(\Sigma\)</span> from a sample of a Wishart distribtution <span class="math inline">\(S\)</span>, and in order to keep the same margins for our chains, we transform <span class="math inline">\(S\)</span> to have ones on the diagonal : <span class="math display">\[
\Sigma = D^{-1/2} S D^{-1/2},
\quad \text{ with } \quad
D = \text{Diag}\left(s_{1,1}, \ldots, s_{d,d}\right)
\]</span></p>
<p>From the theoretical part, we know that the value given by <span class="math inline">\(\hat{R}_\infty\)</span> depends on the direction of dependence. Thus, we can either fix <span class="math inline">\(\Sigma\)</span> and study the behaviour of the different <span class="math inline">\(\hat{R}\)</span>, or sample a new <span class="math inline">\(\Sigma\)</span> for each draw of <span class="math inline">\(\hat{R}\)</span>.</p>
<pre class="r"><code>generate_sigma_matrix &lt;- function(d){
  S &lt;- rWishart(1, d, diag(d))[,,1]
  S &lt;- diag(1/sqrt(diag(S))) %*% S %*% diag(1/sqrt(diag(S)))
  return (S)
}

gen_mvnormal_chains &lt;- function(M, N, d, S=NULL){
  if (is.null(S)){
    S &lt;- generate_sigma_matrix(d)
  }
  return (array(c(mvrnorm((M-1)*N, mu = rep(0, d), Sigma = diag(d)),
                  mvrnorm(N, mu = rep(0, d), Sigma = S)),
                c(N,d,M)))
}</code></pre>
<p>First, we start by considering <span class="math inline">\(d=5\)</span> and study the behavior of <span class="math inline">\(\hat{R}_\infty\)</span> and the multivariate <span class="math inline">\(\hat{R}\)</span> of Brooks and Gelman (1998) on a given <span class="math inline">\(\Sigma\)</span> for the last chain:</p>
<pre class="r"><code>d &lt;- 5

M &lt;- 4
N &lt;- 100
reps &lt;- 100

r_functions &lt;- c(brooks_multivariate_rhat, rhat_infinity)
r_names &lt;- c(&quot;Brooks Multivariate R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[3], colors[4])

S &lt;- generate_sigma_matrix(d)
print(S)</code></pre>
<pre><code>           [,1]      [,2]       [,3]      [,4]       [,5]
[1,]  1.0000000 0.3528609  0.7434603 0.1491803 -0.1380975
[2,]  0.3528609 1.0000000  0.4345097 0.8059773  0.5687374
[3,]  0.7434603 0.4345097  1.0000000 0.1837495 -0.2814009
[4,]  0.1491803 0.8059773  0.1837495 1.0000000  0.2456532
[5,] -0.1380975 0.5687374 -0.2814009 0.2456532  1.0000000</code></pre>
<pre class="r"><code>R_matrix &lt;- repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d, S)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

plot_hist(R_matrix, colors = r_colors, bin_size = 0.002,
          lim_y_axis = 25, vaxis_pos = 1,
          plot_threshold = F)</code></pre>
<p><img src="Simulations_files/figure-html/multivariate_hist1-1.png" width="1152" /></p>
<p>Doing the same experiment but with a new <span class="math inline">\(\Sigma\)</span> on each repetitions will result on a histogram more spread for <span class="math inline">\(\hat{R}_\infty\)</span>:</p>
<pre class="r"><code>d &lt;- 5

M &lt;- 4
N &lt;- 100
reps &lt;- 100

r_functions &lt;- c(brooks_multivariate_rhat, rhat_infinity)
r_names &lt;- c(&quot;Brooks Multivariate R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[3], colors[4])

R_matrix &lt;- repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08)
plot_hist(R_matrix, colors = r_colors,
          xlabels = xlabels, bin_size = 0.002,
          lim_y_axis = 20, vaxis_pos = 0.997,
          plot_threshold = F)</code></pre>
<p><img src="Simulations_files/figure-html/multivariate_hist2-1.png" width="1152" /></p>
<p>To avoid the issue of being sensitive only to a specific direction, <span class="math inline">\(\hat{R}_\infty\)</span> can be computed on all directions, which means if <span class="math inline">\(d=3\)</span> that <span class="math inline">\(\hat{R}\)</span> is computed on <span class="math display">\[
  I\left(\theta_1^{(n,m)} \leq x_1, \theta_2^{(n,m)} \leq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \geq x_1, \theta_2^{(n,m)} \leq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \leq x_1, \theta_2^{(n,m)} \geq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \geq x_1, \theta_2^{(n,m)} \geq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
\]</span> The other half of the possibilities is avoided by symmetry. Then, we can define <span class="math inline">\(\hat{R}^{(\text{max})}_\infty\)</span> as the maximum of all the <span class="math inline">\(\hat{R}_\infty\)</span> computed on all directions. Despite a unreasonable computational cost (with <span class="math inline">\(2^{d-1}\)</span> <span class="math inline">\(\hat{R}_\infty\)</span> to compute), this solutions seems satisfying in small dimension:</p>
<pre class="r"><code>d_max = 6

M = 4
N = 100
reps = 200


r_functions = c(rhat_infinity, rhat_infinity_max_directions)
r_names = c(&quot;One Direction&quot;, &quot;All Directions&quot;)

R_values = repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, 2)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)


R_array = array(c(R_values[,1], rep(&quot;d = 2&quot;, reps), rep(&quot;1 Dir&quot;, reps)), dim = c(reps,3))
R_array = rbind(R_array, array(c(R_values[,2], rep(&quot;d = 2&quot;, reps), rep(&quot;All Dir&quot;, reps)), dim = c(reps,3)))
colnames(R_array) = c(&quot;Values&quot;, &quot;Dim&quot;, &quot;Nb_Dir&quot;)

for (d in 3:d_max){
  R_val_d = repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d)),
                             r_func = r_functions,
                             r_names = r_names,
                             reps = reps)
  d_names = c(paste(&quot;d =&quot;, d))
  R_array = rbind(R_array, array(c(R_val_d[,1], rep(d_names, reps), rep(&quot;1 Dir&quot;, reps)), dim = c(reps,3)))
  R_array = rbind(R_array, array(c(R_val_d[,2], rep(d_names, reps), rep(&quot;All Dir&quot;, reps)), dim = c(reps,3)))

}

R_df = as.data.frame(R_array)
R_df$Values = as.numeric(R_df$Values)

ggplot(R_df, aes(x = Values, y = as.factor(Dim), fill = Nb_Dir)) +
  geom_density_ridges(stat = &quot;binline&quot;, bins= 40,
                      scale = 1, alpha = 0.7) +
  scale_y_discrete(limits = R_df$Dim) +
  ylab(&quot;Dimensions&quot;) + labs(fill = element_blank()) +
  scale_x_continuous(limits = c(1,1.14),
                     n.breaks = 8) +
  scale_fill_manual(values=c(&quot;#32a632&quot;, &quot;#4287f5&quot;)) +
  theme_ridges(font_size=22)</code></pre>
<p><img src="Simulations_files/figure-html/r_dimensions-1.png" width="1152" /></p>
<p>Here, <span class="math inline">\(\hat{R}^{(\text{max})}_\infty\)</span> seems to stay robust with respect to this curse of dimensionality in terms of sensitivity, as the histograms look invariant when <span class="math inline">\(d\)</span> increases, contrary to <span class="math inline">\(\hat{R}_\infty\)</span>.</p>
</div>
</div>
<div id="bayesian-logistic-regression" class="section level2" number="2.3">
<h2 number="2.3"><span class="header-section-number">2.3</span> Bayesian logistic regression</h2>
<p>As a practical bayesian example, we consider hierarchical logistic regression using the following model: <span class="math display">\[\begin{equation*}
    \boldsymbol{\beta} \sim \mathcal{N}(0, 0.35^2. \boldsymbol{I}_4), \quad
    y_j \sim \text{Bernoulli}\left(\frac{1}{1+e^{-\boldsymbol{x}_j^\top\boldsymbol{\beta}}}\right).
\end{equation*}\]</span></p>
<pre class="r"><code>writeLines(readLines(paste(stan_folder, &quot;logit_reg.stan&quot;, sep=&quot;&quot;)))</code></pre>
<pre><code>data {
  int&lt;lower=1&gt; D;
  int&lt;lower=0&gt; N;
  real&lt;lower=0&gt; tau;
  int&lt;lower=0, upper=1&gt; y[N];
  real x[N,D];
}

parameters {
  real bet[D];
}

model {
  for (d in 1:D)
    bet[d] ~ normal(0, tau);

  for (n in 1:N)
    y[n] ~ bernoulli(inv_logit(dot_product(x[n], bet)));
}</code></pre>
<p>We run Stan using the dataset  available in the package .</p>
<pre class="r"><code>data(&quot;logit&quot;)
d &lt;- 4
logit_data&lt;- read_rdump(paste(stan_folder, &quot;logit_reg.data.R&quot;, sep=&quot;&quot;))
fit_logit &lt;- stan(file = paste(stan_folder, &quot;logit_reg.stan&quot;, sep=&quot;&quot;),
                  data=logit_data, seed = 12,
                  iter=200, chains=4, refresh=0)</code></pre>
<pre><code>Running /usr/lib/R/bin/R CMD SHLIB foo.c
gcc -std=gnu99 -std=gnu11 -I&quot;/usr/share/R/include&quot; -DNDEBUG   -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/Rcpp/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/unsupported&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/BH/include&quot; -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/src/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppParallel/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/rstan/include&quot; -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DBOOST_NO_AUTO_PTR  -include &#39;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp&#39;  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1      -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-J7pprH/r-base-4.1.2=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c foo.c -o foo.o
In file included from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Core:88:0,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Dense:1,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:13,
                 from &lt;command-line&gt;:0:
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/src/Core/util/Macros.h:628:1: error: unknown type name ‘namespace’
 namespace Eigen {
 ^~~~~~~~~
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/src/Core/util/Macros.h:628:17: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token
 namespace Eigen {
                 ^
In file included from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Dense:1:0,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:13,
                 from &lt;command-line&gt;:0:
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Core:96:10: fatal error: complex: Aucun fichier ou dossier de ce type
 #include &lt;complex&gt;
          ^~~~~~~~~
compilation terminated.
/usr/lib/R/etc/Makeconf:168: recipe for target &#39;foo.o&#39; failed
make: *** [foo.o] Error 1</code></pre>
<pre class="r"><code>mon &lt;- monitor(fit_logit)

chains &lt;- as.array(fit_logit)
dim_chains &lt;- dim(chains)

rhat_inf &lt;- c()

for (i in 1:dim_chains[3]) {
  chains_i &lt;- chains[, , i]
  rhat_inf_i &lt;- rhat_infinity(chains_i, max_nb_points = &quot;ALL&quot;)
  rhat_inf &lt;- c(rhat_inf, rhat_inf_i)
}

mon[[&quot;Rhat_inf&quot;]] &lt;- rhat_inf
mon</code></pre>
<pre><code>Inference for the input samples (4 chains: each with iter = 200; warmup = 100):

           Q5    Q50    Q95   Mean   SD  Rhat Bulk_ESS Tail_ESS Rhat_inf
bet[1]   0.12   0.50   0.90   0.49 0.23  1.00      410      332     1.02
bet[2]   0.31   0.63   1.01   0.63 0.21  1.01      592      330     1.01
bet[3]  -0.09   0.28   0.67   0.28 0.23  1.01      412      301     1.01
bet[4]   0.02   0.40   0.79   0.41 0.25  1.01      366      263     1.01
lp__   -56.71 -52.81 -51.61 -53.33 1.68  1.02      219      311     1.02

For each parameter, Bulk_ESS and Tail_ESS are crude measures of
effective sample size for bulk and tail quantities respectively (an ESS &gt; 100
per chain is considered good), and Rhat is the potential scale reduction
factor on rank normalized split chains (at convergence, Rhat &lt;= 1.01).</code></pre>
<p>Despite a low number of iterations, all the different univariate <span class="math inline">\(\hat{R}_\infty\)</span> are below <span class="math inline">\(1.03\)</span> when replicated, and the rank-<span class="math inline">\(\hat{R}\)</span> are below <span class="math inline">\(1.01\)</span>. We compare the proportion of <span class="math inline">\(\hat{R}^{(\text{max})}_\infty\)</span> replications over <span class="math inline">\(1.03\)</span>, with the proportion of univariate <span class="math inline">\(\hat{R}_\infty\)</span> for lp__ over <span class="math inline">\(1.02\)</span>:</p>
<pre class="r"><code>reps &lt;- 50

gen_beta_logit &lt;- function(i){
  # fit_logit &lt;- stan(file = paste(stan_folder, &quot;logit_reg.stan&quot;, sep=&quot;&quot;),
                    # data=logit_data,
                    # iter=200, chains=4, refresh=0)
  # saveRDS(fit_logit, paste(stan_folder, &quot;logit/logit_reg_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  fit_logit &lt;- readRDS(paste(stan_folder, &quot;logit/logit_reg_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  mon &lt;- monitor(fit_logit)

  chains &lt;- as.array(fit_logit)

  return (aperm(chains, c(1,3,2)))
}

r_functions = c(brooks_multivariate_rhat, rhat_infinity_max_directions)
r_names = c(&quot;Brooks Multivariate R-hat&quot;, &quot;max-R-hat&quot;)
r_colors = c(colors[4], colors[2])

R_matrix_logit &lt;- repetitions_R(chains_func = gen_beta_logit,
                                 r_func = r_functions,
                                 r_names = r_names,
                                 reps = reps, saved_model = TRUE)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04, 1.05)
plot_hist(R_matrix_logit, colors = r_colors, xlabels = xlabels,
          vaxis_pos = 0.998, plot_threshold = F, threshold = 1.03,
          bin_size = 0.003, lim_y_axis = 25)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-14-1.png" width="1152" /></p>
<pre class="r"><code>gen_beta_logit_lp &lt;- function(i){
  fit_logit &lt;- readRDS(paste(stan_folder, &quot;logit/logit_reg_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  mon &lt;- monitor(fit_logit)
  chains &lt;- as.array(fit_logit)
  return (chains[, , 5])
}

r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;,
             &quot;Rank-R-hat&quot;,
             &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_logit2 &lt;- repetitions_R(chains_func = gen_beta_logit_lp,
                                 r_func = r_functions,
                                 r_names = r_names,
                                 reps = reps, saved_model = TRUE)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04, 1.05)
plot_hist(R_matrix_logit2, colors = r_colors, vaxis_pos = 0.998,
          xlabels = xlabels, plot_threshold = T,
          bin_size = 0.003, lim_y_axis = 25)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-15-1.png" width="1152" /></p>
<p>Both diagnostic looks similar: although most of simulations seems satisfying, a non-negligible part of replications seems to suffer from a lack of convergence.</p>
</div>
</div>
<div id="empirical-examples" class="section level1" number="3">
<h1 number="3"><span class="header-section-number">3</span> Empirical examples</h1>
<p>This section is dedicated to practical case for Bayesian inference.</p>
<div id="autoregressive-model" class="section level2" number="3.1">
<h2 number="3.1"><span class="header-section-number">3.1</span> Autoregressive model</h2>
<p>We start by running a basic autoreggressive model to study the case of a Markov chain with different variance on the chains: <span class="math display">\[\begin{equation*}
  \theta^{(i+1,j)} = \rho \theta^{(i,j)} + \epsilon_{i,j},
  \quad \text{with} \quad
  \epsilon_{i,j} \sim \mathcal{N}(0,\sigma^2_j),
\end{equation*}\]</span> where <span class="math inline">\(\rho \in (0,1)\)</span> and <span class="math inline">\(\sigma_j &gt; 0\)</span>.</p>
<pre class="r"><code>autoregressive &lt;- function(n, rho, sigma){
  chain &lt;- c()
  pre &lt;- 0
  eps &lt;- rnorm(n, 0, sigma)
  for (t in 1:n){
    suiv &lt;- rho*pre+eps[t]
    chain &lt;- c(chain, suiv)
    pre &lt;- suiv
  }
  return(chain)
}

gen_autoreg_chains &lt;- function(M, N, rho, sigma, sigmaM){
  return (array(c(replicate(M-1, autoregressive(N, rho, sigma)),
                  autoregressive(N, rho, sigmaM)), c(N,M)))
}</code></pre>
<p>Clearly <span class="math inline">\(\hat{R}_\infty\)</span> diagnose a convergence issue:</p>
<pre class="r"><code>M &lt;- 4
sigma &lt;- 1
sigmaM &lt;- 2
rho &lt;- 1/2


chains = gen_autoreg_chains(M, N, rho, sigma, sigmaM)
rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.048
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.048033</code></pre>
<pre class="r"><code>simulated_rhat = all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

plot_local_r(chains, simulated_rhat, col=c(colors[3], colors[2]),
             xlim = c(-6,6), ylim=c(1,1.07), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-18-1.png" width="1152" /></p>
<p>Comparison of different versions of <span class="math inline">\(\hat{R}\)</span> using replications:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_autoreg &lt;- repetitions_R(
  chains_func = (function() gen_autoreg_chains(M, N, rho, sigma, sigmaM)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)

plot_hist(R_matrix_autoreg, colors = r_colors,
          xlabels = c(1, 1.02, 1.04, 1.06, 1.08, 1.1),
          bin_size = 0.004, lim_y_axis = 20)</code></pre>
<p><img src="Simulations_files/figure-html/autoreg_hist-1.png" width="1152" /></p>
</div>
<div id="hmc-on-cauchy-distribution" class="section level2" number="3.2">
<h2 number="3.2"><span class="header-section-number">3.2</span> HMC on Cauchy distribution</h2>
In this section, we will study two parameterization of Cauchy using HMC:
<p>One would expect convergence issues with the nominal parameterisation and not with the alternative one. For both, the process of selecting the worst parameters among the <span class="math inline">\(50\)</span> ones is iterated for the generation of replications.</p>
<div id="nominal-parameterization" class="section level3" number="3.2.1">
<h3 number="3.2.1"><span class="header-section-number">3.2.1</span> Nominal parameterization</h3>
<p>Model :</p>
<pre class="r"><code>writeLines(readLines(paste(stan_folder, &quot;cauchy_nom.stan&quot;, sep=&quot;&quot;)))</code></pre>
<pre><code>parameters {
  vector[50] x;
}

model {
  x ~ cauchy(0, 1);
}

generated quantities {
  real I = fabs(x[1]) &lt; 1 ? 1 : 0;
}</code></pre>
<pre class="r"><code># fit_nom &lt;- stan(file = paste(stan_folder, &quot;cauchy_nom.stan&quot;, sep=&quot;&quot;), seed = 7878, refresh = 0)
# saveRDS(fit_nom, paste(stan_folder, &quot;cauchy_nom.rds&quot;, sep=&quot;&quot;))
fit_nom &lt;- readRDS(paste(stan_folder, &quot;cauchy_fits/cauchy_nom.rds&quot;, sep=&quot;&quot;))

mon &lt;- monitor(fit_nom)

which_max_rhat &lt;- which.max(mon[1:50, &#39;Rhat&#39;])
max_rhat &lt;- max(mon[1:50, &#39;Rhat&#39;])

subset(mon, Rhat == max_rhat)</code></pre>
<pre><code>Inference for the input samples ( chains: each with iter = ; warmup = ):

        Q5  Q50    Q95  Mean   SD  Rhat Bulk_ESS Tail_ESS
x[18] -4.1 0.56 172.82 35.87 65.4  1.54        7       32

For each parameter, Bulk_ESS and Tail_ESS are crude measures of
effective sample size for bulk and tail quantities respectively (an ESS &gt; 100
per chain is considered good), and Rhat is the potential scale reduction
factor on rank normalized split chains (at convergence, Rhat &lt;= 1.01).</code></pre>
<p>Plot of <span class="math inline">\(\hat{R}(x)\)</span>:</p>
<pre class="r"><code>chains &lt;- as.array(fit_nom)
dim_chains &lt;- dim(chains)

rhat_inf &lt;- c()

for (i in 1:dim_chains[3]) {
  chains_i &lt;- chains[, , i]
  rhat_inf_i &lt;- rhat_infinity(chains_i)
  rhat_inf &lt;- c(rhat_inf, rhat_inf_i)
}

mon[[&quot;Rhat_inf&quot;]] &lt;- rhat_inf
which_max_rhat_inf &lt;- which.max(mon[1:50, &#39;Rhat_inf&#39;])

rhat_infinity(chains[ , , which_max_rhat_inf], verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  7.364
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 7.364029</code></pre>
<pre class="r"><code>simulated_rhat = all_local_rhat(chains[ , , which_max_rhat_inf], max_nb_points = &quot;ALL&quot;)

xlabels = 1:10

plot_local_r(chains[ , , which_max_rhat_inf], simulated_rhat,
             col=c(colors[3], colors[2]), xlabels = xlabels,
             xlim = c(-50,200), ylim=c(1,10), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-23-1.png" width="1152" /></p>
<p>Comparison of different versions of <span class="math inline">\(\hat{R}\)</span> using replications:</p>
<pre class="r"><code>gen_diverging_cauchy &lt;- function(i){
  # fit_nom &lt;- stan(file = paste(stan_folder, &quot;cauchy_nom.stan&quot;, sep=&quot;&quot;), refresh = 0)
  # saveRDS(fit_nom, paste(stan_folder, &quot;cauchy_fits/cauchy_nom_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  fit_nom &lt;- readRDS(paste(stan_folder, &quot;cauchy_fits/cauchy_nom_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))


  mon &lt;- monitor(fit_nom)
  chains &lt;- as.array(fit_nom)
  dim_chains &lt;- dim(chains)

  rhat_inf &lt;- c()

  for (i in 1:dim_chains[3]) {
    chains_i &lt;- chains[, , i]
    rhat_inf_i &lt;- rhat_infinity(chains_i)
    rhat_inf &lt;- c(rhat_inf, rhat_inf_i)
  }
  mon[[&quot;Rhat_inf&quot;]] &lt;- rhat_inf
  which_max_rhat_inf &lt;- which.max(mon[1:50, &#39;Rhat_inf&#39;])

  return (chains[, , which_max_rhat_inf])
}

r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_cauchy &lt;- repetitions_R(chains_func = gen_diverging_cauchy,
                                 r_func = r_functions,
                                 r_names = r_names,
                                 reps = reps, saved_model = TRUE)

xlabels = c(1, 1.1, 1.2, 1.3, 1.4)
plot_hist(R_matrix_cauchy, colors = r_colors, xlabels = xlabels,
          bin_size = 0.017, lim_y_axis = 20)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-24-1.png" width="1152" /></p>
</div>
<div id="alternative-parameterization" class="section level3" number="3.2.2">
<h3 number="3.2.2"><span class="header-section-number">3.2.2</span> Alternative parameterization</h3>
<p>Model :</p>
<pre class="r"><code>writeLines(readLines(paste(stan_folder, &quot;cauchy_alt_1.stan&quot;, sep=&quot;&quot;)))</code></pre>
<pre><code>parameters {
  vector[50] x_a;
  vector&lt;lower=0&gt;[50] x_b;
}

transformed parameters {
  vector[50] x = x_a ./ sqrt(x_b);
}

model {
  x_a ~ normal(0, 1);
  x_b ~ gamma(0.5, 0.5);
}

generated quantities {
  real I = fabs(x[1]) &lt; 1 ? 1 : 0;
}</code></pre>
<pre class="r"><code># fit_alt1 &lt;- stan(file = paste(stan_folder, &quot;cauchy_alt_1.stan&quot;, sep=&quot;&quot;), seed = 7878, refresh = 0)
# saveRDS(fit_alt1, paste(stan_folder, &quot;cauchy_fits/cauchy_alt.rds&quot;, sep=&quot;&quot;))
fit_alt1 &lt;- readRDS(paste(stan_folder, &quot;cauchy_fits/cauchy_alt.rds&quot;, sep=&quot;&quot;))
mon &lt;- monitor(fit_alt1)


which_max_rhat &lt;- which.max(mon[101:150, &#39;Rhat&#39;])
max_rhat &lt;- max(mon[101:150, &#39;Rhat&#39;])
subset(mon, Rhat == max_rhat)</code></pre>
<pre><code>Inference for the input samples ( chains: each with iter = ; warmup = ):

         Q5  Q50  Q95  Mean     SD  Rhat Bulk_ESS Tail_ESS
x[40] -6.22 0.03 6.33 -6.15 204.09     1     3667     2250

For each parameter, Bulk_ESS and Tail_ESS are crude measures of
effective sample size for bulk and tail quantities respectively (an ESS &gt; 100
per chain is considered good), and Rhat is the potential scale reduction
factor on rank normalized split chains (at convergence, Rhat &lt;= 1.01).</code></pre>
<p>Plot of <span class="math inline">\(\hat{R}(x)\)</span>:</p>
<pre class="r"><code>chains &lt;- as.array(fit_alt1)
dim_chains &lt;- dim(chains)

rhat_inf &lt;- c()

for (i in 1:dim_chains[3]) {
  chains_i &lt;- chains[, , i]
  rhat_inf_i &lt;- rhat_infinity(chains_i)
  rhat_inf &lt;- c(rhat_inf, rhat_inf_i)
}

mon[[&quot;Rhat_inf&quot;]] &lt;- rhat_inf
which_max_rhat_inf &lt;- which.max(mon[101:150, &#39;Rhat_inf&#39;])

rhat_infinity(chains[ , , which_max_rhat_inf], verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.0015
p-value:  1
At 5%, no convergence issues have been diagnosed</code></pre>
<pre><code>[1] 1.001452</code></pre>
<pre class="r"><code>simulated_rhat = all_local_rhat(chains[ , , which_max_rhat_inf], max_nb_points = &quot;ALL&quot;)

xlabels = c(1, 1.01, 1.02, 1.03)
plot_local_r(chains[, , which_max_rhat], simulated_rhat,
             col=c(colors[3], colors[2]), xlabels = xlabels,
             xlim = c(-4,4), ylim=c(0.9995,1.03), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-29-1.png" width="1152" /></p>
<p>Comparison of different versions of <span class="math inline">\(\hat{R}\)</span> using replications:</p>
<pre class="r"><code>gen_converging_cauchy &lt;- function(i){
  # fit_nom &lt;- stan(file = paste(stan_folder, &quot;cauchy_alt_1.stan&quot;, sep=&quot;&quot;), refresh = 0)
  # saveRDS(fit_nom, paste(stan_folder, &quot;cauchy_fits/cauchy_alt_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  fit_nom &lt;- readRDS(paste(stan_folder, &quot;cauchy_fits/cauchy_alt_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))

  mon &lt;- monitor(fit_nom)
  chains &lt;- as.array(fit_nom)
  dim_chains &lt;- dim(chains)

  rhat_inf &lt;- c()

  for (i in 1:dim_chains[3]) {
    chains_i &lt;- chains[, , i]
    rhat_inf_i &lt;- rhat_infinity(chains_i)
    rhat_inf &lt;- c(rhat_inf, rhat_inf_i)
  }
  mon[[&quot;Rhat_inf&quot;]] &lt;- rhat_inf
  which_max_rhat_inf &lt;- which.max(mon[101:150, &#39;Rhat_inf&#39;])

  return (chains[, , which_max_rhat_inf])
}

r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_cauchy2 &lt;- repetitions_R(chains_func = gen_converging_cauchy,
                                  r_func = r_functions,
                                  r_names = r_names,
                                  reps = reps,
                                  saved_model = TRUE)

xlabels = c(1, 1.005, 1.01, 1.015, 1.02, 1.025, 1.03)
plot_hist(R_matrix_cauchy2, colors = r_colors, xlabels = xlabels,
          bin_size = 0.0018, lim_y_axis = reps)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-30-1.png" width="1152" /></p>
</div>
</div>
<div id="hierarchical-model-eight-schools" class="section level2" number="3.3">
<h2 number="3.3"><span class="header-section-number">3.3</span> Hierarchical model: Eight Schools</h2>
<p>Model :</p>
<pre class="r"><code>writeLines(readLines(paste(stan_folder, &quot;eight_schools_cp.stan&quot;, sep=&quot;&quot;)))</code></pre>
<pre><code>data {
  int&lt;lower=0&gt; J;
  real y[J];
  real&lt;lower=0&gt; sigma[J];
}

parameters {
  real mu;
  real&lt;lower=0&gt; tau;
  real theta[J];
}

model {
  mu ~ normal(0, 5);
  tau ~ cauchy(0, 5);
  theta ~ normal(mu, tau);
  y ~ normal(theta, sigma);
}</code></pre>
<p>As a classical Bayesian example, we consider using HMC on a hierarchical Bayesian model and in particular the eight-school, where two parameterisations are possible to model the problem:</p>
<pre><code>1. Centered parameterisation (CP):
$\theta_j \sim \mathcal{N}(\mu,\tau), \quad y_j \sim \mathcal{N}(\theta_j,\sigma^2_j)$
2. Non-centered parameterisation (NCP):
$\bar{\theta}_j \sim \mathcal{N}(0,1), \quad  \theta_j = \mu + \tau \bar{\theta}_j, \quad y_j \sim \mathcal{N}(\theta_j,\sigma^2_j)$</code></pre>
<p>Similarly to Vehtari et al. (2021), we analyse convergence of the chains by studying parameter <span class="math inline">\(\tau\)</span>.</p>
<div id="centered-parameterisation" class="section level3" number="3.3.1">
<h3 number="3.3.1"><span class="header-section-number">3.3.1</span> Centered parameterisation</h3>
<pre class="r"><code>eight_schools &lt;- read_rdump(paste(stan_folder, &quot;eight_schools.data.R&quot;, sep=&quot;&quot;))
# fit_cp &lt;- stan(
#   file = paste(stan_folder, &quot;eight_schools_cp.stan&quot;, sep=&quot;&quot;), data = eight_schools,
#   iter = 2000, chains = 4, seed = 120, refresh = 0,
#   control = list(adapt_delta = 0.95)
# )
# saveRDS(fit_cp, paste(stan_folder, &quot;eight_schools_fits/eight_schools_cp.rds&quot;, sep=&quot;&quot;))
fit_cp &lt;- readRDS(paste(stan_folder, &quot;eight_schools_fits/eight_schools_cp.rds&quot;, sep=&quot;&quot;))

mon &lt;- monitor(fit_cp)
print(mon)</code></pre>
<pre><code>Inference for the input samples (4 chains: each with iter = 2000; warmup = 1000):

             Q5    Q50   Q95   Mean   SD  Rhat Bulk_ESS Tail_ESS
mu        -0.94   4.84  9.48   4.80 3.32  1.04       87      693
tau        0.64   2.80 10.29   3.77 3.27  1.06       94      123
theta[1]  -1.48   6.43 17.06   6.68 5.81  1.01      622     1021
theta[2]  -2.61   5.52 12.57   5.35 4.79  1.02      309     1192
theta[3]  -5.21   4.62 11.85   4.31 5.40  1.03      169     1291
theta[4]  -3.41   5.29 12.03   5.04 4.80  1.03      216     1617
theta[5]  -4.66   4.21 10.29   3.80 4.82  1.03      216     1155
theta[6]  -4.38   4.69 11.01   4.40 4.88  1.02      186     1648
theta[7]  -0.77   6.65 15.36   6.74 5.03  1.01      525      844
theta[8]  -3.48   5.46 13.39   5.31 5.32  1.02      467     1290
lp__     -25.23 -14.77 -2.54 -14.33 7.04  1.08       46      104

For each parameter, Bulk_ESS and Tail_ESS are crude measures of
effective sample size for bulk and tail quantities respectively (an ESS &gt; 100
per chain is considered good), and Rhat is the potential scale reduction
factor on rank normalized split chains (at convergence, Rhat &lt;= 1.01).</code></pre>
<p>Plot of <span class="math inline">\(\hat{R}(x)\)</span></p>
<pre class="r"><code>chains &lt;- as.array(fit_cp)
dim_chains &lt;- dim(chains)

simulated_rhat = all_local_rhat(chains[, , &quot;tau&quot;], max_nb_points = &quot;ALL&quot;)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)

plot_local_r(chains[, , &quot;tau&quot;], simulated_rhat,
             col=c(colors[3], colors[2]), xlabels = xlabels,
             xlim = c(0,25), ylim=c(0.999,1.04), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-34-1.png" width="1152" /></p>
<p>Comparison of different versions of <span class="math inline">\(\hat{R}\)</span> using replications:</p>
<pre class="r"><code>gen_centered_eight_school &lt;- function(i){
  # fit_cp &lt;- stan(
  #   file = paste(stan_folder, &quot;eight_schools_cp.stan&quot;, sep=&quot;&quot;), data = eight_schools,
  #   iter = 2000, chains = 4, refresh = 0,
  #   control = list(adapt_delta = 0.95)
  # )
  # saveRDS(fit_cp, paste(stan_folder, &quot;eight_schools_fits/eight_schools_cp_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  fit_cp &lt;- readRDS(paste(stan_folder, &quot;eight_schools_fits/eight_schools_cp_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))

  mon &lt;- monitor(fit_cp)
  chains &lt;- as.array(fit_cp)

  return (chains[, , &quot;tau&quot;])
}

r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_8schools &lt;- repetitions_R(chains_func = gen_centered_eight_school,
                                   r_func = r_functions,
                                   r_names = r_names,
                                   reps = reps,
                                   saved_model = TRUE)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08, 1.1, 1.12, 1.14)
plot_hist(R_matrix_8schools, colors = r_colors, xlabels = xlabels,
          bin_size = 0.005, lim_y_axis = 30)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-35-1.png" width="1152" /></p>
</div>
<div id="non-centered-parameterisation" class="section level3" number="3.3.2">
<h3 number="3.3.2"><span class="header-section-number">3.3.2</span> Non-centered parameterisation</h3>
<p>Model :</p>
<pre class="r"><code>writeLines(readLines(paste(stan_folder, &quot;eight_schools_ncp.stan&quot;, sep=&quot;&quot;)))</code></pre>
<pre><code>data {
  int&lt;lower=0&gt; J;
  real y[J];
  real&lt;lower=0&gt; sigma[J];
}

parameters {
  real mu;
  real&lt;lower=0&gt; tau;
  real theta_tilde[J];
}

transformed parameters {
  real theta[J];
  for (j in 1:J)
    theta[j] = mu + tau * theta_tilde[j];
}

model {
  mu ~ normal(0, 5);
  tau ~ cauchy(0, 5);
  theta_tilde ~ normal(0, 1);
  y ~ normal(theta, sigma);
}</code></pre>
<pre class="r"><code>fit_ncp2 &lt;- stan(
  file = paste(stan_folder, &quot;eight_schools_ncp.stan&quot;, sep=&quot;&quot;), data = eight_schools,
  iter = 2000, chains = 4, seed = 483892929, refresh = 0,
  control = list(adapt_delta = 0.95)
)</code></pre>
<pre><code>Running /usr/lib/R/bin/R CMD SHLIB foo.c
gcc -std=gnu99 -std=gnu11 -I&quot;/usr/share/R/include&quot; -DNDEBUG   -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/Rcpp/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/unsupported&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/BH/include&quot; -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/src/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppParallel/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/rstan/include&quot; -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DBOOST_NO_AUTO_PTR  -include &#39;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp&#39;  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1      -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-J7pprH/r-base-4.1.2=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c foo.c -o foo.o
In file included from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Core:88:0,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Dense:1,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:13,
                 from &lt;command-line&gt;:0:
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/src/Core/util/Macros.h:628:1: error: unknown type name ‘namespace’
 namespace Eigen {
 ^~~~~~~~~
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/src/Core/util/Macros.h:628:17: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token
 namespace Eigen {
                 ^
In file included from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Dense:1:0,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:13,
                 from &lt;command-line&gt;:0:
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Core:96:10: fatal error: complex: Aucun fichier ou dossier de ce type
 #include &lt;complex&gt;
          ^~~~~~~~~
compilation terminated.
/usr/lib/R/etc/Makeconf:168: recipe for target &#39;foo.o&#39; failed
make: *** [foo.o] Error 1</code></pre>
<pre class="r"><code># saveRDS(fit_ncp2, paste(stan_folder, &quot;eight_schools_fits/eight_schools_ncp.rds&quot;, sep=&quot;&quot;))
fit_ncp2 &lt;- readRDS(paste(stan_folder, &quot;eight_schools_fits/eight_schools_ncp.rds&quot;, sep=&quot;&quot;))


mon &lt;- monitor(fit_ncp2)
print(mon)</code></pre>
<pre><code>Inference for the input samples (4 chains: each with iter = 2000; warmup = 1000):

                   Q5   Q50   Q95  Mean   SD  Rhat Bulk_ESS Tail_ESS
mu              -1.13  4.53  9.85  4.49 3.32     1     5375     3332
tau              0.26  2.79  9.74  3.56 3.09     1     3281     2729
theta_tilde[1]  -1.30  0.32  1.87  0.30 0.97     1     5571     3052
theta_tilde[2]  -1.42  0.08  1.55  0.08 0.90     1     4405     2885
theta_tilde[3]  -1.69 -0.10  1.45 -0.09 0.96     1     5486     2531
theta_tilde[4]  -1.52  0.05  1.64  0.05 0.94     1     5183     3102
theta_tilde[5]  -1.64 -0.16  1.33 -0.16 0.91     1     4884     3289
theta_tilde[6]  -1.60 -0.07  1.46 -0.07 0.94     1     5584     3087
theta_tilde[7]  -1.26  0.38  1.91  0.36 0.96     1     4977     3112
theta_tilde[8]  -1.52  0.07  1.64  0.07 0.96     1     5209     3039
theta[1]        -1.73  5.67 15.98  6.13 5.53     1     4803     3138
theta[2]        -2.50  4.87 12.61  4.94 4.56     1     5830     3692
theta[3]        -4.28  4.21 11.75  4.03 5.08     1     4702     3378
theta[4]        -2.70  4.80 12.40  4.78 4.75     1     5451     3472
theta[5]        -3.95  4.02 10.82  3.76 4.62     1     5179     3486
theta[6]        -4.22  4.31 11.42  4.08 4.93     1     5537     3372
theta[7]        -1.04  6.01 15.22  6.37 5.07     1     5121     3569
theta[8]        -3.13  4.90 13.09  4.95 5.19     1     5124     3452
lp__           -11.02 -6.52 -3.62 -6.83 2.31     1     1850     2629

For each parameter, Bulk_ESS and Tail_ESS are crude measures of
effective sample size for bulk and tail quantities respectively (an ESS &gt; 100
per chain is considered good), and Rhat is the potential scale reduction
factor on rank normalized split chains (at convergence, Rhat &lt;= 1.01).</code></pre>
<p>Plot of <span class="math inline">\(\hat{R}(x)\)</span>:</p>
<pre class="r"><code>chains &lt;- as.array(fit_ncp2)
dim_chains &lt;- dim(chains)

simulated_rhat = all_local_rhat(chains[, , &quot;tau&quot;], max_nb_points = &quot;ALL&quot;)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_local_r(chains[, , &quot;tau&quot;], simulated_rhat,
             col=c(colors[3], colors[2]), xlabels = xlabels,
             xlim = c(0,25), ylim=c(0.999,1.04), title =&quot;&quot;)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-39-1.png" width="1152" /></p>
<p>Comparison of different versions of <span class="math inline">\(\hat{R}\)</span> using replications:</p>
<pre class="r"><code>gen_ncp_eight_school &lt;- function(i){
  # fit_ncp2 &lt;- stan(
  #   file = paste(stan_folder, &quot;eight_schools_ncp.stan&quot;, sep=&quot;&quot;), data = eight_schools,
  #   iter = 2000, chains = 4, refresh = 0,
  #   control = list(adapt_delta = 0.95)
  # )
  # saveRDS(fit_ncp2, paste(stan_folder, &quot;eight_schools_fits/eight_schools_ncp_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  fit_ncp2 &lt;- readRDS(paste(stan_folder, &quot;eight_schools_fits/eight_schools_ncp_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  mon &lt;- monitor(fit_ncp2)
  chains &lt;- as.array(fit_ncp2)

  return (chains[, , &quot;tau&quot;])
}

r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_8schools2 &lt;- repetitions_R(chains_func = gen_ncp_eight_school,
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps,
                         saved_model = TRUE)

xlabels = c(1, 1.005, 1.01, 1.015, 1.02, 1.025, 1.03)
plot_hist(R_matrix_8schools2, colors = r_colors, xlabels = xlabels,
          bin_size = 0.0015, lim_y_axis = reps)</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-40-1.png" width="1152" /></p>
</div>
</div>
<div id="summary-1" class="section level2" number="3.4">
<h2 number="3.4"><span class="header-section-number">3.4</span> Summary</h2>
<p>The following boxplot summarizes the values of replicated <span class="math inline">\(\hat{R}\)</span>, rank-<span class="math inline">\(\hat{R}\)</span> and <span class="math inline">\(\hat{R}_\infty\)</span> on the different examples of this section:</p>
<pre class="r"><code>data=data.frame(r_version, r_experiment,  r_values)

ggplot(data, aes(x=r_experiment, y=r_values, fill=r_version)) +
    geom_boxplot() +
    geom_hline(yintercept=1.01, linetype=&quot;dashed&quot;,
               color = &quot;black&quot;, size=0.5) +
      geom_hline(yintercept=1.02, linetype=&quot;dashed&quot;,
             color = &quot;green&quot;, size=0.5) +
    xlab(&quot;Experiments&quot;) + ylab(&quot;Values&quot;) + ylim(1, 1.3)</code></pre>
<pre><code>Warning: Removed 36 rows containing non-finite values (stat_boxplot).</code></pre>
<p><img src="Simulations_files/figure-html/unnamed-chunk-42-1.png" width="1152" /></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
