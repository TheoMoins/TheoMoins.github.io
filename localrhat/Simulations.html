<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Théo Moins, Julyan Arbel, Stéphane Girard, Anne Dutfoy" />


<title>On the use of local ˆR to improve MCMC convergence diagnostic</title>

<script src="Simultations_files/header-attrs-2.11/header-attrs.js"></script>
<script src="Simultations_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Simultations_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="Simultations_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Simultations_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Simultations_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="Simultations_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="Simultations_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="Simultations_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="Simultations_files/navigation-1.1/tabsets.js"></script>
<link href="Simultations_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="Simultations_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">



<h1 class="title toc-ignore">On the use of local ˆR to improve MCMC convergence diagnostic</h1>
<h4 class="author">Théo Moins, Julyan Arbel, Stéphane Girard, Anne Dutfoy</h4>
<h4 class="date">5/2/2022</h4>

</div>


<pre class="r"><code>library(&quot;EnvStats&quot;)
library(&#39;jmuOutlier&#39;)
library(&quot;ggplot2&quot;)
library(&quot;rstan&quot;)

devtools::load_all()

source(paste(r_folder, &quot;import/monitornew.R&quot;, sep=&quot;&quot;))
source(paste(r_folder, &quot;import/r_star_monitor.R&quot;, sep=&quot;&quot;))

reps &lt;- 500</code></pre>
<p><span class="math display">\[\begin{equation}
    \label{eq:R_theorique}
    R(x) = \sqrt{\frac{W(x)+B(x)}{W(x)}} = \sqrt{1 + \frac{\sum_{j=1}^m\sum_{k=j+1}^m \left(F_j(x)-F_k(x)\right)^2}{m\sum_{j=1}^m F_j(x)(1-F_j(x))}}.
\end{equation}\]</span></p>
<div id="known-distributions-on-the-chains" class="section level1" number="1">
<h1 number="1"><span class="header-section-number">1</span> Known distributions on the chains</h1>
<div id="counter-examples-for-hatr" class="section level2" number="1.1">
<h2 number="1.1"><span class="header-section-number">1.1</span> Counter examples for <span class="math inline">\(\hat{R}\)</span></h2>
<div id="example-i-uniform-distribution" class="section level3" number="1.1.1">
<h3 number="1.1.1"><span class="header-section-number">1.1.1</span> Example (i): Uniform distribution</h3>
<p>As a first example we consider <span class="math inline">\(m\)</span> chains following centered uniform distributions, with the last having a different support than the other: <span class="math display">\[\begin{align*}
  F_1(x) &amp;= \cdots = F_{m-1}(x) =  \frac{x}{2\sigma} + \frac{1}{2}, \quad \forall x \in \left[-\sigma; \sigma\right],\\
  \text{and}\quad F_m(x) &amp;=  \frac{x}{2\sigma_m} + \frac{1}{2}, \quad \forall x \in \left[-\sigma_m; \sigma_m\right].
\end{align*}\]</span></p>
<p>In such a case the expression of <span class="math inline">\(R(x)\)</span> is explicit and can be compared to the estimator <span class="math inline">\(\hat{R}(x)\)</span>: to illustrate we choose <span class="math inline">\(m=4\)</span> chains, <span class="math inline">\(\sigma = 3/4\)</span> and <span class="math inline">\(\sigma_m = 1\)</span>.</p>
<pre class="r"><code>sigma &lt;- 3/4
sigmaM &lt;- 1
M &lt;- 4
N &lt;- 200

uniform_dists &lt;- c(rep(c((function(q) punif(q, -sigma, sigma))), M-1),
                   (function(q) punif(q, -sigmaM, sigmaM)))

theoretical_r_values &lt;- r_dist_values(npoints = N, xlim = c(-sigmaM, sigmaM),
                                      dists = uniform_dists)

uniform_rdists &lt;- c((function(n) runif(n, -sigma, sigma)),
                    (function(n) runif(n, -sigmaM, sigmaM)))

chains = gen_chains(M, N, uniform_rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.0476
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.047596</code></pre>
<pre class="r"><code>simulated_rhat = all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08)
plot_local_r(chains, simulated_rhat, theoretical_r_values, col=c(colors[3], colors[2]),
             xlabels = xlabels, plot_legend = FALSE,
             xlim = c(-1,1), ylim=c(1,1.09), title =&quot;&quot;)</code></pre>
<p><img src="Simultations_files/figure-html/uniform_r_x2-1.png" width="1152" /></p>
<p>We can see that <span class="math inline">\(\hat{R}(x)\)</span> (in violet) slightly overestimate <span class="math inline">\(R(x)\)</span>, which makes it more conservative than the population value.</p>
<p>We replicate the experiment 500 times and study the histogram of replications of different versions of <span class="math inline">\(\hat{R}\)</span>:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;,
             &quot;Rank-R-hat&quot;,
             &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08, 1.1)

plot_hist(R_matrix_unif, colors = r_colors, xlabels = xlabels,
          bin_size = 0.005, lim_y_axis = reps, plot_legend = F)</code></pre>
<p><img src="Simultations_files/figure-html/uniform_hist-1.png" width="1152" /></p>
<p>As constructed initially by Vehtari et al. (2021), this example fool the original <span class="math inline">\(\hat{R}\)</span>. The rank version and <span class="math inline">\(\hat{R}_\infty\)</span> is on the contrary robust in this case.</p>
</div>
<div id="example-ii-pareto-distribution" class="section level3" number="1.1.2">
<h3 number="1.1.2"><span class="header-section-number">1.1.2</span> Example (ii): Pareto distribution</h3>
<p>Similarly, we check the second counter-example that fool the original <span class="math inline">\(\hat{R}\)</span>: chains with heavy-tails and different locations. To do so we consider Pareto distributions on the chains: <span class="math display">\[\begin{align*}
    F_1(x) &amp;= \cdots = F_{m-1}(x) = 1 - \left({x}/{\eta}\right)^{-\alpha},
    \quad \forall x \in [\eta, +\infty),\\
    \text{and}\quad F_m(x) &amp;=  1 - \left({x}/{\eta_m}\right)^{-\alpha},
    \quad \forall x \in [\eta_m, +\infty).
\end{align*}\]</span></p>
<p>As an example, we choose <span class="math inline">\(\alpha = 0.8 \leq 1\)</span> to ensure infinite moments and <span class="math inline">\((\eta, \eta_m) = (1, 1.5)\)</span>:</p>
<pre class="r"><code>eta &lt;- 1
etaM &lt;- 1.5
alpha &lt;- 0.8
M &lt;- 4

pareto_dists &lt;- c(rep(c((function(q) ppareto(q, location = eta, shape = alpha))), M-1),
                  (function(q) ppareto(q, location = etaM, shape = alpha)))

theoretical_r_values &lt;- r_dist_values(npoints = 1000, xlim = c(-eta, eta*8), 
                                      dists = pareto_dists)

pareto_rdists &lt;- c((function(n) rpareto(n, location = eta, shape = alpha)),
                   (function(n) rpareto(n, location = etaM, shape = alpha)))

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08)
chains &lt;- gen_chains(M, N, pareto_rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.0498
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.049801</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

plot_local_r(chains, simulated_rhat, theoretical_r_values,
             plot_legend = FALSE, col=c(colors[3], colors[2]),
             xlabels = xlabels, xlim = c(1,8), ylim=c(1,1.09), title =&quot;&quot;)</code></pre>
<p><img src="Simultations_files/figure-html/pareto_r_x2-1.png" width="1152" /></p>
<p>The same observations as for the previous example can be done here: <span class="math inline">\(\hat{R}_\infty\)</span> overestimates <span class="math inline">\(R_\infty\)</span>, whose value already allowed the diagnosis of a convergence issue. We can verify the behaviour on replications:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_pareto &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08)
plot_hist(R_matrix_pareto, colors = r_colors, xlabels = xlabels,
          plot_legend = FALSE, bin_size = 0.005, lim_y_axis = 500)</code></pre>
<p><img src="Simultations_files/figure-html/pareto_hists-1.png" width="1152" /></p>
</div>
</div>
<div id="counter-examples-for-rank-hatr" class="section level2" number="1.2">
<h2 number="1.2"><span class="header-section-number">1.2</span> Counter examples for rank-<span class="math inline">\(\hat{R}\)</span></h2>
<p>In this part, We will see 3 cases where rank-<span class="math inline">\(\hat{R}\)</span> doesn’t manage to detect the convergence issue. These cases correspond to chains with different type of distributions, but with same mean and mean over the median.</p>
<div id="example-iii-uniform-and-laplace-distributions" class="section level3" number="1.2.1">
<h3 number="1.2.1"><span class="header-section-number">1.2.1</span> Example (iii): Uniform and Laplace distributions</h3>
<p>We start by an example where the population version can be computed explicitly: if one chain is uniformly distributed <span class="math inline">\(\mathcal{U}(-2\sigma, 2\sigma)\)</span> and another one from a Laplace distribution <span class="math inline">\(\mathcal{L}(0, \sigma)\)</span>, where <span class="math inline">\(\sigma&gt;0\)</span>, then calculations leads to <span class="math inline">\(R_\infty \approx 1.018\)</span>, which means convergence issue.</p>
<pre class="r"><code>sigma &lt;- 1/4
M &lt;- 2


dists &lt;- c((function(q) punif(q, -2*sigma, 2*sigma)),
           (function(q) plaplace(q, mean = 0, sd = sqrt(2)*sigma)))


theoretical_r_values &lt;- r_dist_values(npoints = 1000, xlim = c(-1.5, 1.5), 
                                      dists = dists)


rdists &lt;- c((function(n) runif(n, -2*sigma, 2*sigma)),
            (function(n) rlaplace(n, mean = 0, sd = sqrt(2)*sigma)))


chains &lt;- gen_chains(M, N, rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0125
Local R-hat obtained:  1.0244
p-value:  0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.024427</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.01, 1.02, 1.03)

plot_local_r(chains, simulated_rhat, theoretical_r_values, threshold = 1.01,
             xlabels = xlabels, col = c(colors[3], colors[2]),
             xlim = c(-1.5,1.5), ylim=c(1,1.03), title =&quot;&quot;)</code></pre>
<p><img src="Simultations_files/figure-html/laplace_uniform_x2-1.png" width="1152" /></p>
<p>Replications show that rank-<span class="math inline">\(\hat{R}\)</span> is fooled in the same way as <span class="math inline">\(\hat{R}\)</span> in this example:</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_lapl_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)

plot_hist(R_matrix_lapl_unif, colors = r_colors, bin_size = 0.003,
          xlabels = xlabels, plot_legend = TRUE, threshold = 1.01,
          lim_y_axis = reps, vaxis_pos = 0.9985)</code></pre>
<p><img src="Simultations_files/figure-html/laplace_uniform_hists-1.png" width="1152" /></p>
</div>
<div id="example-iv-uniform-and-normal-distributions" class="section level3" number="1.2.2">
<h3 number="1.2.2"><span class="header-section-number">1.2.2</span> Example (iv): Uniform and Normal distributions</h3>
<p>Similarly, others distributions are possible to build counter-examples. Consider <span class="math inline">\(m-1\)</span> normal chains <span class="math inline">\(\mathcal{N}\left(0, \frac{\pi}{2}\sigma^2\right)\)</span> and for the last one a uniform <span class="math inline">\(\mathcal{U}(-2\sigma, 2\sigma)\)</span>:</p>
<pre class="r"><code>sigma &lt;- 1/2
M &lt;- 2

dists &lt;- c((function(q) pnorm(q, mean = 0, sd = sqrt(0.5*pi)*sigma)),
           (function(q) punif(q, -2*sigma, 2*sigma)))

theoretical_r_values &lt;- r_dist_values(npoints = 1000, xlim = c(-2, 2), 
                                      dists = dists)

rdists &lt;- c((function(n) rnorm(n, mean = 0, sd = sqrt(0.5*pi)*sigma)),
            (function(n) runif(n, -2*sigma, 2*sigma)))

chains &lt;- gen_chains(M, 2*N, rdists)

rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0125
Local R-hat obtained:  1.0194
p-value:  0.003
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.019354</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.005, 1.01, 1.015, 1.02)

plot_local_r(chains, simulated_rhat, theoretical_r_values, 
             xlabels = xlabels, col=c(colors[3], colors[2]), threshold = 1.01,
             xlim = c(-2,2), ylim=c(0.999,1.025), title =&quot;Gaussian/Uniform distributions&quot;)</code></pre>
<p><img src="Simultations_files/figure-html/gaussian_uniform_x2-1.png" width="1152" /></p>
<p>Replications confirms that this construction are fooling the different versions of <span class="math inline">\(\hat{R}\)</span> except <span class="math inline">\(\hat{R}_\infty\)</span>.</p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_norm_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.01, 1.02, 1.03)
plot_hist(R_matrix_norm_unif, colors = r_colors, xlabels = xlabels,
          bin_size = 0.002, plot_legend = TRUE, threshold = 1.01,
          lim_y_axis = reps, vaxis_pos = 0.999)</code></pre>
<p><img src="Simultations_files/figure-html/gaussian_uniform_hists-1.png" width="1152" /></p>
</div>
<div id="example-v-uniform-and-exponential-distributions" class="section level3" number="1.2.3">
<h3 number="1.2.3"><span class="header-section-number">1.2.3</span> Example (v): Uniform and Exponential distributions</h3>
<p>Finally, it is also possible to mix uniform distributions with exponential:</p>
<pre class="r"><code>M &lt;- 4
N &lt;- 200

min_unif &lt;- 1-2*log(2)
max_unif &lt;- 1+2*log(2)


dists &lt;- c(rep(c((function(q) pexp(q))), M-1),
           (function(q) punif(q, min_unif, max_unif)))

theoretical_r_values &lt;- r_dist_values(npoints = 500, xlim = c(-1, 6), 
                                      dists = dists)

rdists &lt;- c((function(n) rexp(n)),
            (function(n) runif(n, min_unif, max_unif)))

chains &lt;- gen_chains(M, N, rdists)
rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0195
Local R-hat obtained:  1.0545
p-value: &lt; 0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.054547</code></pre>
<pre class="r"><code>simulated_rhat &lt;- all_local_rhat(chains, max_nb_points = &quot;ALL&quot;)

xlabels &lt;- c(1, 1.02, 1.04, 1.06, 1.08)
plot_local_r(chains, simulated_rhat, theoretical_r_values,
             xlabels = xlabels, col = c(colors[3], colors[2]),
             xlim = c(-1, 6), ylim=c(1,1.09), title =&quot;&quot;)</code></pre>
<p><img src="Simultations_files/figure-html/exp_uniform_x2-1.png" width="1152" /></p>
<pre class="r"><code>r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;, &quot;Rank-R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_exp_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

plot_hist(R_matrix_exp_unif, colors = r_colors, bin_size = 0.007, 
          lim_y_axis = 500, vaxis_pos = 0.997)</code></pre>
<p><img src="Simultations_files/figure-html/exp_uniform_hists-1.png" width="1152" /></p>
</div>
</div>
<div id="threshold-estimation" class="section level2" number="1.3">
<h2 number="1.3"><span class="header-section-number">1.3</span> Threshold estimation</h2>
<p>In this part we focus on the case where all the distributions are the same, to verify the behavior in the null hypothesis.</p>
<pre class="r"><code>M &lt;- 2
N &lt;- 200

colors_same &lt;- c(rgb(0.55, 0, 0.4, 0.8), rgb(0.4, 0, 0.7, 0.8), rgb(0.5, 0, 0.5, 0.9))

R_matrix_same_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c(&quot;Uniform&quot;),
                                    reps = reps)

R_matrix_same_par &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c(&quot;Pareto&quot;),
                                   reps = reps)

R_matrix_same_unif_par &lt;- cbind(R_matrix_same_unif, R_matrix_same_par)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          threshold = 1.01001, xlabels = xlabels, bin_size = 0.0020, 
          lim_y_axis = 200, vaxis_pos = 0.9985, plot_legend = F)</code></pre>
<p><img src="Simultations_files/figure-html/same_uniform_hists1-1.png" width="1152" /></p>
<pre class="r"><code>M &lt;- 4
N &lt;- 100

R_matrix_same_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c(&quot;Uniform&quot;),
                                    reps = reps)

R_matrix_same_par &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c(&quot;Pareto&quot;),
                                   reps = reps)

R_matrix_same_unif_par &lt;- cbind(R_matrix_same_unif, R_matrix_same_par)


xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          xlabels = xlabels, bin_size = 0.002, threshold = 1.02,
          lim_y_axis = 200, vaxis_pos = 0.9985, plot_legend = F)</code></pre>
<p><img src="Simultations_files/figure-html/same_uniform_hists2-1.png" width="1152" /></p>
<pre class="r"><code>M &lt;- 8
N &lt;- 50

R_matrix_same_unif &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c(&quot;Uniform&quot;),
                                    reps = reps)

R_matrix_same_par &lt;- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c(&quot;Pareto&quot;),
                                   reps = reps)

R_matrix_same_unif_par &lt;- cbind(R_matrix_same_unif, R_matrix_same_par)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          threshold = 1.03, xlabels = xlabels, bin_size = 0.002, 
          lim_y_axis = 200, vaxis_pos = 0.9985)</code></pre>
<p><img src="Simultations_files/figure-html/same_uniform_hists3-1.png" width="1152" /></p>
</div>
<div id="summary" class="section level2" number="1.4">
<h2 number="1.4"><span class="header-section-number">1.4</span> Summary</h2>
<pre class="r"><code>data=data.frame(r_version, r_experiment,  r_values)

ggplot(data, aes(x=r_experiment, y=r_values, fill=r_version)) +
    geom_boxplot() + 
    geom_hline(yintercept=1.01, linetype=&quot;dashed&quot;, 
               color = &quot;black&quot;, size=0.5) +
    geom_hline(yintercept=1.02, linetype=&quot;dashed&quot;, 
             color = &quot;green&quot;, size=0.5) +
    xlab(&quot;Experiments&quot;) + ylab(&quot;Values&quot;)</code></pre>
<p><img src="Simultations_files/figure-html/unnamed-chunk-8-1.png" width="1152" /></p>
</div>
</div>
<div id="multivariate-examples" class="section level1" number="2">
<h1 number="2"><span class="header-section-number">2</span> Multivariate examples</h1>
<p>In the multivariate case when <span class="math inline">\(\boldsymbol{\theta}=(\theta_1, \ldots, \theta_d)\in{\mathbb R}^d\)</span>, we suggest to apply <span class="math inline">\(\hat{R}\)</span> on a multivariate indicator variable <span class="math inline">\(I_{\boldsymbol{x}}^{(j)} = \mathbb{I}\{\theta_1^{(j)} \leq x_1, \ldots, \theta_d^{(j)} \leq x_d\}\)</span> for any <span class="math inline">\(\boldsymbol{x} = (x_1, \ldots, x_d) \in \mathbb{R}^d\)</span> in two steps:</p>
<p>Thus we recommend to compute the multivariate version only in the case where all the univariate one doesn’t detect any convergence issue, this is why in the part we will focus only of cases where the margins are the same (for example uniform).</p>
<pre class="r"><code>library(&quot;MASS&quot;) # For Multivariate Normal Distribution
library(&quot;stableGR&quot;) # For the R-hat version of Vats and Knudson (2018)
library(&quot;coda&quot;) # For an implementation of the multivariate R-hat of Brooks and Gelman (1998)
library(&quot;rWishart&quot;) # Wishart distribution
library(&quot;mcmc&quot;) # for logit data
library(&quot;ggridges&quot;)


brooks_multivariate_rhat &lt;- function(chaines){
  R_star_chains = aperm(chaines, c(1, 3, 2))
  return (r_hat_multivariate(R_star_chains, split_chains = F))
}

coda_multivariate_rhat &lt;- function(chaines){
  chaines_list = list()
  for (i in 1:dim(chaines)[3]){
    mcmc_ch &lt;- as.mcmc(chaines[,,i])
    chaines_list[[i]] &lt;- as.mcmc(chaines[,,i])
  }
  mcmc_chains = do.call(mcmc.list, list(chaines_list))
  return (gelman.diag(mcmc_chains)$mpsrf)
}</code></pre>
<div id="bivariate-case-normal-distributions" class="section level2" number="2.1">
<h2 number="2.1"><span class="header-section-number">2.1</span> Bivariate Case: Normal distributions</h2>
<p>In this section, we focus on two-dimensional parameters on which we aim at diagnose convergence of the corresponding MCMC (with any number of chains). This restriction allows to navigate easily between the positive dependence and the negative one of the two components.</p>
<p>In particular, we consider bivariate normal densities with zero means, and compare <span class="math inline">\(m-1\)</span> chains with identity covariance matrix, and one with non-zero off-diagonal elements <span class="math inline">\(\rho \in (-1,1)\)</span>.</p>
<p>We start by define the function that will allows us to generate <span class="math inline">\(m\)</span> chains of size <span class="math inline">\(n\)</span> with this configuration :</p>
<pre class="r"><code>gen_bvnormal_chains &lt;- function(M, N, rho){
  sig_matrix &lt;- (1-rho) * diag(2) + matrix(rho, nrow=2, ncol=2)
  return (array(c(mvrnorm((M-1)*N, mu = rep(0, 2), Sigma = diag(2)), 
                  mvrnorm(N, mu = rep(0, 2), Sigma = sig_matrix)), c(N,2,M)))
}</code></pre>
<p>As an example, we consider the case with <span class="math inline">\(m=2\)</span> chains of size <span class="math inline">\(n=100\)</span>, and <span class="math inline">\(\rho = 0.9\)</span> on the last chain. This choice of <span class="math inline">\(n\)</span> relatively small is due to the fact the elements in the chain are i.i.d here, so <span class="math inline">\(n\)</span> can be seen as an effective sample size for a given chain here.</p>
<pre class="r"><code>rho &lt;- 0.9
M &lt;- 2
N &lt;- 200

chains &lt;- gen_bvnormal_chains(M, N, rho)
rhat_infinity(chains, verbose = T)</code></pre>
<pre><code>Threshold at confidence level 5%:  1.0125
Local R-hat obtained:  1.0245
p-value:  0.001
WARNING: A convergence issue has been diagnosed</code></pre>
<pre><code>[1] 1.024456</code></pre>
<p>We simulate 100 experiments, which result as 100 draws of the different <span class="math inline">\(\hat{R}\)</span>.</p>
<p>Histogram of the corresponding values of <span class="math inline">\(\hat{R}_\infty\)</span> and the multivariate <span class="math inline">\(\hat{R}\)</span> of Brooks and Gelman (1998) :</p>
<pre class="r"><code>rho &lt;- 0.9
M &lt;- 2
N &lt;- 200
reps &lt;- 100

r_functions = c(brooks_multivariate_rhat, rhat_infinity)
r_names = c(&quot;Brooks Multivariate R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors = c(colors[4], colors[3])

R_matrix = repetitions_R(chains_func = (function() gen_bvnormal_chains(M, N, rho)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08, 1.1, 1.12)
plot_hist(R_matrix, colors = r_colors, bin_size = 0.0045, 
          lim_y_axis = 30, vaxis_pos = 0.995,
          xlabels = xlabels, plot_threshold = F)</code></pre>
<p><img src="Simultations_files/figure-html/bivariate_hists2-1.png" width="1152" /></p>
<div id="evolution-of-the-different-value-of-hatr-with-rho" class="section level3" number="2.1.1">
<h3 number="2.1.1"><span class="header-section-number">2.1.1</span> Evolution of the different value of <span class="math inline">\(\hat{R}\)</span> with <span class="math inline">\(\rho\)</span></h3>
<p>Except for <span class="math inline">\(R^*\)</span>, we consider the mean of the 100 draws for the different versions of <span class="math inline">\(\hat{R}\)</span>, and plot the evolution of this value with <span class="math inline">\(\rho\)</span>:</p>
<pre class="r"><code>rho_list = c(-0.99, -0.9, -0.7, -0.5, -0.2, 0, 0.2, 0.5, 0.7, 0.9, 0.99)

d &lt;- 2
M &lt;- 2
N &lt;- 500
reps &lt;- 10


r_functions &lt;- c(rhat_infinity, brooks_multivariate_rhat)
r_names &lt;- c(&quot;R-hat-infinity&quot;, &quot;Brooks R-hat&quot;)

R_values &lt;- c()
x_val &lt;- c()
theoretical_R &lt;- c()


for (rho in rho_list){
  R_val_rho = repetitions_R(chains_func = (function() gen_bvnormal_chains(M, N, rho)), 
                                    r_func = r_functions, 
                                    r_names = r_names, 
                                    reps = reps)
  R_values = rbind(R_values, R_val_rho)
  x_val = c(x_val, rep(rho, reps))
  
  sig_matrix &lt;- (1-rho) * diag(2) + matrix(rho, nrow=2, ncol=2)
  dists &lt;- c((function(q) mvtnorm::pmvnorm(upper = q, sigma = diag(2))[1]),
             (function(q) mvtnorm::pmvnorm(upper = q, sigma = sig_matrix)[1]))
  theoretical_R = c(theoretical_R, max_r_dist_bivariate(npoints = 200, 
                                                        xlim = c(-3,3), 
                                                        dists = dists))
}

par(mar=c(4,5.5,2,2))
plot(x=x_val, y=R_values[,1],
     col = c(colors[3]), pch = 19,
     xlab = expression(rho[&quot;m&quot;]), ylab = &quot;&quot;,
     xaxs=&quot;i&quot;, yaxs=&quot;i&quot;, bty = &quot;n&quot;,
     xaxt = &quot;n&quot;, yaxt = &quot;n&quot;,
     cex.lab = 2, cex.main = 2,
     lwd=9,
     xlim = c(-1.01, 1.02), ylim = c(0.999,1.155))
points(x=x_val, y=R_values[,2], 
       col = c(colors[4]), pch = 19,
       lwd=9)
lines(rho_list, theoretical_R, type=&quot;l&quot;, col = colors[2], lwd=6, lty = 2)
points(x=rho_list, y=theoretical_R, 
       col = c(colors[2]), pch = 19,
       lwd=9)
xlabels = c(1, 1.03, 1.06, 1.09, 1.12, 1.15)
ylabels = c(-1, -0.5, 0, 0.5, 1)
axis(1, labels=ylabels, at=ylabels, cex.axis=2, lwd=3, mgp = c(1,1,0))
axis(2, labels=xlabels, at=xlabels, cex.axis=2, mgp = c(1,0.5,0), lwd=2)
legend(x=0.6, y=1.14, col=c(colors[4], colors[3], colors[2]), pch=19, 
       legend = c(expression(italic(hat(R))),
                  expression(italic(hat(R)[infinity])),
                  expression(italic(R[infinity]))), cex=2)</code></pre>
<p><img src="Simultations_files/figure-html/bivariate_rho-1.png" width="1152" /></p>
<p>Remarks :</p>
<ul>
<li>Our version is the most sensitive, and is more sensitive as <span class="math inline">\(|\rho|\)</span> increases (which is great)</li>
<li>The asymmetry can be link to the theoretical computations. WARNING: in the case where <span class="math inline">\(d=2\)</span>, the orders on the two bounds PQD and NQD are inverted (compared to the asymptotic behavior), and that is why here we are more sensitive when <span class="math inline">\(\rho &lt; 0\)</span> (which is counter-intuitive)</li>
</ul>
</div>
</div>
<div id="general-number-of-dimensions" class="section level2" number="2.2">
<h2 number="2.2"><span class="header-section-number">2.2</span> General number of dimensions</h2>
<div id="generation-of-a-covariance-matrix" class="section level3" number="2.2.1">
<h3 number="2.2.1"><span class="header-section-number">2.2.1</span> Generation of a covariance matrix</h3>
<p>In the general case, we still compare <span class="math inline">\(m-1\)</span> chains that follows a multivariate normal distribution with identity covariance matrix with one that has a given covariance matrix <span class="math inline">\(\Sigma\)</span>.</p>
<p>We generate <span class="math inline">\(\Sigma\)</span> from a sample of a Wishart distribtution <span class="math inline">\(S\)</span>, and in order to keep the same margins for our chains, we transform <span class="math inline">\(S\)</span> to have ones on the diagonal : <span class="math display">\[
\Sigma = D^{-1/2} S D^{-1/2}, 
\quad \text{ with } \quad 
D = \text{Diag}\left(s_{1,1}, \ldots, s_{d,d}\right)
\]</span></p>
<p>From the theoretical part, we know that the value given by <span class="math inline">\(\hat{R}_\infty\)</span> depends on the direction of dependence. Thus, we can either fix <span class="math inline">\(\Sigma\)</span> and study the behaviour of the different <span class="math inline">\(\hat{R}\)</span>, or sample a new <span class="math inline">\(\Sigma\)</span> for each draw of <span class="math inline">\(\hat{R}\)</span>.</p>
<pre class="r"><code>generate_sigma_matrix &lt;- function(d){
  S &lt;- rWishart(1, d, diag(d))[,,1]
  S &lt;- diag(1/sqrt(diag(S))) %*% S %*% diag(1/sqrt(diag(S)))
  return (S)
}

gen_mvnormal_chains &lt;- function(M, N, d, S=NULL){
  if (is.null(S)){
    S &lt;- generate_sigma_matrix(d)
  }
  return (array(c(mvrnorm((M-1)*N, mu = rep(0, d), Sigma = diag(d)), 
                  mvrnorm(N, mu = rep(0, d), Sigma = S)), 
                c(N,d,M)))
}</code></pre>
<p>First, we start by considering <span class="math inline">\(d=5\)</span> and study the behavior of <span class="math inline">\(\hat{R}_\infty\)</span> and the multivariate <span class="math inline">\(\hat{R}\)</span> of Brooks and Gelman (1998) on a given <span class="math inline">\(\Sigma\)</span> for the last chain:</p>
<pre class="r"><code>d &lt;- 5

M &lt;- 4
N &lt;- 100
reps &lt;- 100

r_functions &lt;- c(brooks_multivariate_rhat, rhat_infinity)
r_names &lt;- c(&quot;Brooks Multivariate R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[3], colors[4])

S &lt;- generate_sigma_matrix(d)
print(S)</code></pre>
<pre><code>           [,1]        [,2]       [,3]        [,4]        [,5]
[1,]  1.0000000 -0.67289587 -0.8116578  0.27111833 -0.15643808
[2,] -0.6728959  1.00000000  0.5652830  0.11993363  0.09229557
[3,] -0.8116578  0.56528305  1.0000000  0.25080351  0.21448793
[4,]  0.2711183  0.11993363  0.2508035  1.00000000 -0.02406259
[5,] -0.1564381  0.09229557  0.2144879 -0.02406259  1.00000000</code></pre>
<pre class="r"><code>R_matrix &lt;- repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d, S)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

plot_hist(R_matrix, colors = r_colors, bin_size = 0.002, 
          lim_y_axis = 25, vaxis_pos = 1,
          plot_threshold = F)</code></pre>
<p><img src="Simultations_files/figure-html/multivariate_hist1-1.png" width="1152" /></p>
<p>Doing the same experiment but with a new <span class="math inline">\(\Sigma\)</span> on each repetitions will result on a histogram more spread for <span class="math inline">\(\hat{R}_\infty\)</span>:</p>
<pre class="r"><code>d &lt;- 5

M &lt;- 4
N &lt;- 100
reps &lt;- 100

r_functions &lt;- c(brooks_multivariate_rhat, rhat_infinity)
r_names &lt;- c(&quot;Brooks Multivariate R-hat&quot;, &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[3], colors[4])

R_matrix &lt;- repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08)
plot_hist(R_matrix, colors = r_colors, 
          xlabels = xlabels, bin_size = 0.002, 
          lim_y_axis = 20, vaxis_pos = 0.997,
          plot_threshold = F)</code></pre>
<p><img src="Simultations_files/figure-html/multivariate_hist2-1.png" width="1152" /></p>
<p>To avoid this issue, <span class="math inline">\(\hat{R}_\infty\)</span> can be computed on all directions, which means if <span class="math inline">\(d=3\)</span> that <span class="math inline">\(\hat{R}\)</span> is computed on <span class="math display">\[
  I\left(\theta_1^{(n,m)} \leq x_1, \theta_2^{(n,m)} \leq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \geq x_1, \theta_2^{(n,m)} \leq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \leq x_1, \theta_2^{(n,m)} \geq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \geq x_1, \theta_2^{(n,m)} \geq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
\]</span> The other half of the possibilities is avoided by symmetry. Then, we can define <span class="math inline">\(\hat{R}^{(\text{max})}_\infty\)</span> as the maximum of all the <span class="math inline">\(\hat{R}_\infty\)</span> computed on all directions. Despite a unreasonable computational cost (with <span class="math inline">\(2^{d-1}\)</span> <span class="math inline">\(\hat{R}_\infty\)</span> to compute), this solutions seems satisfying in small dimension:</p>
<pre class="r"><code>d_max = 6

M = 4
N = 100
reps = 200


r_functions = c(rhat_infinity, rhat_infinity_max_directions)
r_names = c(&quot;One Direction&quot;, &quot;All Directions&quot;)

R_values = repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, 2)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)


R_array = array(c(R_values[,1], rep(&quot;d = 2&quot;, reps), rep(&quot;1 Dir&quot;, reps)), dim = c(reps,3))
R_array = rbind(R_array, array(c(R_values[,2], rep(&quot;d = 2&quot;, reps), rep(&quot;All Dir&quot;, reps)), dim = c(reps,3)))
colnames(R_array) = c(&quot;Values&quot;, &quot;Dim&quot;, &quot;Nb_Dir&quot;)

for (d in 3:d_max){
  R_val_d = repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d)),
                             r_func = r_functions,
                             r_names = r_names,
                             reps = reps)
  d_names = c(paste(&quot;d =&quot;, d))
  R_array = rbind(R_array, array(c(R_val_d[,1], rep(d_names, reps), rep(&quot;1 Dir&quot;, reps)), dim = c(reps,3)))
  R_array = rbind(R_array, array(c(R_val_d[,2], rep(d_names, reps), rep(&quot;All Dir&quot;, reps)), dim = c(reps,3)))

}

R_df = as.data.frame(R_array)
R_df$Values = as.numeric(R_df$Values)

# pdf(file = &quot;/scratch/tmoins/Documents/Code_rhat/figure_article/hist_directions.pdf&quot;, width = 18, height = 8)
ggplot(R_df, aes(x = Values, y = as.factor(Dim), fill = Nb_Dir)) +
  geom_density_ridges(stat = &quot;binline&quot;, bins= 40,
                      scale = 1, alpha = 0.7) +
  scale_y_discrete(limits = R_df$Dim) +
  ylab(&quot;Dimensions&quot;) + labs(fill = element_blank()) +
  scale_x_continuous(limits = c(1,1.14),
                     n.breaks = 8) +
  scale_fill_manual(values=c(&quot;#32a632&quot;, &quot;#4287f5&quot;)) +
  theme_ridges(font_size=22)</code></pre>
<p><img src="Simultations_files/figure-html/r_dimensions-1.png" width="1152" /></p>
<pre class="r"><code># dev.off()</code></pre>
<p>(WARNING: <span class="math inline">\(d&gt;6\)</span> the chunk is very dangerous to run!!)</p>
</div>
</div>
<div id="logistic-regression" class="section level2" number="2.3">
<h2 number="2.3"><span class="header-section-number">2.3</span> Logistic regression</h2>
<p>As a practical bayesian example, we consider hierarchical logistic regression using the following model:</p>
<pre class="r"><code>writeLines(readLines(paste(stan_folder, &quot;logit_reg.stan&quot;, sep=&quot;&quot;)))</code></pre>
<pre><code>data {
  int&lt;lower=1&gt; D;
  int&lt;lower=0&gt; N;
  real&lt;lower=0&gt; tau;
  int&lt;lower=0, upper=1&gt; y[N];
  real x[N,D];
}

parameters {
  real bet[D];
}

model {
  for (d in 1:D)
    bet[d] ~ normal(0, tau);    

  for (n in 1:N)
    y[n] ~ bernoulli(inv_logit(dot_product(x[n], bet)));
}</code></pre>
<p>We run Stan using the dataset  available in the package .</p>
<pre class="r"><code>data(&quot;logit&quot;)
d &lt;- 4
logit_data&lt;- read_rdump(paste(stan_folder, &quot;logit_reg.data.R&quot;, sep=&quot;&quot;))
fit_logit &lt;- stan(file = paste(stan_folder, &quot;logit_reg.stan&quot;, sep=&quot;&quot;),
                  data=logit_data, seed = 12,
                  iter=200, chains=4, refresh=0)</code></pre>
<pre><code>Running /usr/lib/R/bin/R CMD SHLIB foo.c
gcc -std=gnu99 -std=gnu11 -I&quot;/usr/share/R/include&quot; -DNDEBUG   -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/Rcpp/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/unsupported&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/BH/include&quot; -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/src/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppParallel/include/&quot;  -I&quot;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/rstan/include&quot; -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DBOOST_NO_AUTO_PTR  -include &#39;/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp&#39;  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1      -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-J7pprH/r-base-4.1.2=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c foo.c -o foo.o
In file included from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Core:88:0,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Dense:1,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:13,
                 from &lt;command-line&gt;:0:
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/src/Core/util/Macros.h:628:1: error: unknown type name ‘namespace’
 namespace Eigen {
 ^~~~~~~~~
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/src/Core/util/Macros.h:628:17: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token
 namespace Eigen {
                 ^
In file included from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Dense:1:0,
                 from /scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:13,
                 from &lt;command-line&gt;:0:
/scratch/tmoins/R/x86_64-pc-linux-gnu-library/4.1/RcppEigen/include/Eigen/Core:96:10: fatal error: complex: Aucun fichier ou dossier de ce type
 #include &lt;complex&gt;
          ^~~~~~~~~
compilation terminated.
/usr/lib/R/etc/Makeconf:168: recipe for target &#39;foo.o&#39; failed
make: *** [foo.o] Error 1</code></pre>
<pre class="r"><code>mon &lt;- monitor(fit_logit)

chains &lt;- as.array(fit_logit)
dim_chains &lt;- dim(chains)

rhat_inf &lt;- c()

for (i in 1:dim_chains[3]) {
  chains_i &lt;- chains[, , i]
  rhat_inf_i &lt;- rhat_infinity(chains_i, max_nb_points = &quot;ALL&quot;)
  rhat_inf &lt;- c(rhat_inf, rhat_inf_i)
}

mon[[&quot;Rhat_inf&quot;]] &lt;- rhat_inf

mon</code></pre>
<pre><code>Inference for the input samples (4 chains: each with iter = 200; warmup = 100):

           Q5    Q50    Q95   Mean   SD  Rhat Bulk_ESS Tail_ESS Rhat_inf
bet[1]   0.12   0.50   0.90   0.49 0.23  1.00      410      332     1.02
bet[2]   0.31   0.63   1.01   0.63 0.21  1.01      592      330     1.01
bet[3]  -0.09   0.28   0.67   0.28 0.23  1.01      412      301     1.01
bet[4]   0.02   0.40   0.79   0.41 0.25  1.01      366      263     1.01
lp__   -56.71 -52.81 -51.61 -53.33 1.68  1.02      219      311     1.02

For each parameter, Bulk_ESS and Tail_ESS are crude measures of 
effective sample size for bulk and tail quantities respectively (an ESS &gt; 100 
per chain is considered good), and Rhat is the potential scale reduction 
factor on rank normalized split chains (at convergence, Rhat &lt;= 1.01).</code></pre>
<pre class="r"><code>summary(mon[1:d, &#39;Rhat&#39;])</code></pre>
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.002   1.004   1.006   1.006   1.009   1.011 </code></pre>
<pre class="r"><code>summary(mon[1:d, &#39;Rhat_inf&#39;])</code></pre>
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.007   1.011   1.012   1.014   1.015   1.022 </code></pre>
<pre class="r"><code>mon[d+1, &quot;Rhat_inf&quot;]</code></pre>
<pre><code>    lp__ 
1.015831 </code></pre>
<pre class="r"><code>perm_chains &lt;- aperm(chains, c(1,3,2))
rhat_infinity_max_directions(perm_chains)</code></pre>
<pre><code>[1] 1.03357</code></pre>
<pre class="r"><code>reps &lt;- 50

gen_beta_logit &lt;- function(i){
  # fit_logit &lt;- stan(file = paste(stan_folder, &quot;logit_reg.stan&quot;, sep=&quot;&quot;),
                    # data=logit_data,
                    # iter=200, chains=4, refresh=0)
  # saveRDS(fit_logit, paste(stan_folder, &quot;logit/logit_reg_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  fit_logit &lt;- readRDS(paste(stan_folder, &quot;logit/logit_reg_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  mon &lt;- monitor(fit_logit)
  
  chains &lt;- as.array(fit_logit)
  
  return (aperm(chains, c(1,3,2)))
}

r_functions = c(brooks_multivariate_rhat, rhat_infinity_max_directions)
r_names = c(&quot;Brooks Multivariate R-hat&quot;, &quot;max-R-hat&quot;)
r_colors = c(colors[4], colors[2])

R_matrix_logit &lt;- repetitions_R(chains_func = gen_beta_logit, 
                                 r_func = r_functions, 
                                 r_names = r_names, 
                                 reps = reps, saved_model = TRUE)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04, 1.05)
plot_hist(R_matrix_logit, colors = r_colors, xlabels = xlabels,
          vaxis_pos = 0.998, plot_threshold = F, threshold = 1.03,
          bin_size = 0.003, lim_y_axis = 25)</code></pre>
<p><img src="Simultations_files/figure-html/unnamed-chunk-14-1.png" width="1152" /></p>
<pre class="r"><code>gen_beta_logit_lp &lt;- function(i){
  fit_logit &lt;- readRDS(paste(stan_folder, &quot;logit/logit_reg_&quot;, i, &quot;.rds&quot;, sep=&quot;&quot;))
  mon &lt;- monitor(fit_logit)
  chains &lt;- as.array(fit_logit)
  return (chains[, , 5])
}

r_functions &lt;- c(trad_rhat, rhat, rhat_infinity)
r_names &lt;- c(&quot;R-hat&quot;,
             &quot;Rank-R-hat&quot;,
             &quot;R-hat-infinity&quot;)
r_colors &lt;- c(colors[4], colors[5], colors[3])

R_matrix_logit2 &lt;- repetitions_R(chains_func = gen_beta_logit_lp, 
                                 r_func = r_functions, 
                                 r_names = r_names, 
                                 reps = reps, saved_model = TRUE)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04, 1.05)
plot_hist(R_matrix_logit2, colors = r_colors, vaxis_pos = 0.998,
          xlabels = xlabels, plot_threshold = T,
          bin_size = 0.003, lim_y_axis = 25)</code></pre>
<p><img src="Simultations_files/figure-html/unnamed-chunk-15-1.png" width="1152" /></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
