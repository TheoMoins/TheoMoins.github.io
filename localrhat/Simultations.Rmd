---
title: "On the use of a local ˆR to improve MCMC convergence diagnostic"
author: "Théo Moins, Julyan Arbel, Stéphane Girard, Anne Dutfoy"
date: "5/2/2022"
output: 
  html_document: 
    self_contained: no
    toc: yes
    number_sections: yes
    toc_float:
      smooth_scroll: no
encoding: "UTF-8"
---


```{r setup, include=FALSE}

knitr::opts_chunk$set(
  comment = NA, 
  cache = FALSE,
  fig.width = 12,
  fig.height = 8,
  message = FALSE,
  dev = c("png", "pdf")
)
options(width = 100)

# Working directory : localrhat
r_folder <- "../R/"
stan_folder <- "./stan_files/"
```


```{r, comment=NA, message=FALSE, warning=FALSE, results='hide', cache=FALSE}
library("EnvStats")
library('jmuOutlier')
library("ggplot2")
library("rstan")

devtools::load_all()

source(paste(r_folder, "import/monitornew.R", sep=""))
source(paste(r_folder, "import/r_star_monitor.R", sep=""))

reps <- 500
```


```{r, include=FALSE}
r_star_gbm <- function(chaines){
  dim_chaines <- dim(chaines)
  R_star_chains <- array(dim = c(dim_chaines[1], dim_chaines[2], 1))
  R_star_chains[,,1] <- chaines
  return (r_star(R_star_chains, method = "gbm"))
}

gen_chains <- function(M, N, rdists){
  return (array(c(rdists[[1]]((M-1)*N), rdists[[2]](N)), c(N,M)))
}

repetitions_R <- function(chains_func, r_func, r_names, 
                          reps=100, saved_model=FALSE){
  ncolumn <- length(r_func)
  R_values <- c()
  for (f in r_func){
    vect <- c()
    for (e in 1:reps){
      if (saved_model){
        chaines <- chains_func(e)
      } else {
        chaines <- chains_func() 
      }
      vect <- c(vect, f(chaines))
    }
    R_values = c(R_values, vect)
  }
  M <- matrix(data = R_values, ncol = ncolumn)
  colnames(M) <- r_names
  return (M)
}

colors <- c(rgb(0.1,0.6,0.1,0.7), rgb(0.1,0.1,0.7,0.7), rgb(0.5, 0, 0.5, 0.9), rgb(0.8, 0.1, 0.1, 0.9), rgb(1,0.6,0,0.9))

r_version <- c()
r_experiment <- c()
r_values <- c()

```

\begin{equation}
    \label{eq:R_theorique}
    R(x) = \sqrt{\frac{W(x)+B(x)}{W(x)}} = \sqrt{1 + \frac{\sum_{j=1}^m\sum_{k=j+1}^m \left(F_j(x)-F_k(x)\right)^2}{m\sum_{j=1}^m F_j(x)(1-F_j(x))}}.
\end{equation}

# Known distributions on the chains

## Counter examples for $\hat{R}$

### Example (i): Uniform distribution

As a first example we consider $m$ chains following centered uniform distributions, 
with the last having a different support than the other:
\begin{align*}
  F_1(x) &= \cdots = F_{m-1}(x) =  \frac{x}{2\sigma} + \frac{1}{2}, \quad \forall x \in \left[-\sigma; \sigma\right],\\
  \text{and}\quad F_m(x) &=  \frac{x}{2\sigma_m} + \frac{1}{2}, \quad \forall x \in \left[-\sigma_m; \sigma_m\right].
\end{align*}

In such a case the expression of $R(x)$ is explicit and can be compared to the estimator $\hat{R}(x)$:
to illustrate we choose $m=4$ chains, $\sigma = 3/4$ and $\sigma_m = 1$.

```{r uniform_r_x, warning=FALSE}
sigma <- 3/4
sigmaM <- 1
M <- 4
N <- 200

uniform_dists <- c(rep(c((function(q) punif(q, -sigma, sigma))), M-1),
                   (function(q) punif(q, -sigmaM, sigmaM)))

theoretical_r_values <- r_dist_values(npoints = N, xlim = c(-sigmaM, sigmaM),
                                      dists = uniform_dists)

uniform_rdists <- c((function(n) runif(n, -sigma, sigma)),
                    (function(n) runif(n, -sigmaM, sigmaM)))

chains = gen_chains(M, N, uniform_rdists)

rhat_infinity(chains, verbose = T)
```


```{r uniform_r_x2, warning=FALSE}
simulated_rhat = all_local_rhat(chains, max_nb_points = "ALL")

xlabels <- c(1, 1.02, 1.04, 1.06, 1.08)
plot_local_r(chains, simulated_rhat, theoretical_r_values, col=c(colors[3], colors[2]),
             xlabels = xlabels, plot_legend = FALSE,
             xlim = c(-1,1), ylim=c(1,1.09), title ="")
```


We can see that $\hat{R}(x)$ (in violet) slightly overestimate $R(x)$, which makes it more conservative than
the population value. 

We replicate the experiment 500 times and study the histogram of replications of
different versions of $\hat{R}$:

```{r uniform_hist, warning=FALSE}
r_functions <- c(trad_rhat, rhat, rhat_infinity)
r_names <- c("R-hat",
             "Rank-R-hat",
             "R-hat-infinity")
r_colors <- c(colors[4], colors[5], colors[3])

R_matrix_unif <- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels <- c(1, 1.02, 1.04, 1.06, 1.08, 1.1)

plot_hist(R_matrix_unif, colors = r_colors, xlabels = xlabels,
          bin_size = 0.005, lim_y_axis = reps, plot_legend = F)
```

As constructed initially by Vehtari et al. (2021), this example fool the original $\hat{R}$.
The rank version and $\hat{R}_\infty$ is on the contrary robust in this case.

```{r, include=FALSE}
r_version <- c(r_version, 
               rep(colnames(R_matrix_unif)[1], dim(R_matrix_unif)[1]),
               rep(colnames(R_matrix_unif)[2], dim(R_matrix_unif)[1]),
               rep(colnames(R_matrix_unif)[3], dim(R_matrix_unif)[1]))
r_experiment <- c(r_experiment, rep("1.Uniform", length(R_matrix_unif)))
r_values <- c(r_values, as.vector(R_matrix_unif))
```


### Example (ii): Pareto distribution

Similarly, we check the second counter-example that fool the original $\hat{R}$:
chains with heavy-tails and different locations. To do so we consider Pareto 
distributions on the chains:
\begin{align*}
    F_1(x) &= \cdots = F_{m-1}(x) = 1 - \left({x}/{\eta}\right)^{-\alpha},
    \quad \forall x \in [\eta, +\infty),\\
    \text{and}\quad F_m(x) &=  1 - \left({x}/{\eta_m}\right)^{-\alpha},
    \quad \forall x \in [\eta_m, +\infty).
\end{align*}

As an example, we choose $\alpha = 0.8 \leq 1$ to ensure infinite moments and 
$(\eta, \eta_m) = (1, 1.5)$: 

```{r pareto_r_x, warning=FALSE}
eta <- 1
etaM <- 1.5
alpha <- 0.8
M <- 4

pareto_dists <- c(rep(c((function(q) ppareto(q, location = eta, shape = alpha))), M-1),
                  (function(q) ppareto(q, location = etaM, shape = alpha)))

theoretical_r_values <- r_dist_values(npoints = 1000, xlim = c(-eta, eta*8), 
                                      dists = pareto_dists)

pareto_rdists <- c((function(n) rpareto(n, location = eta, shape = alpha)),
                   (function(n) rpareto(n, location = etaM, shape = alpha)))

xlabels <- c(1, 1.02, 1.04, 1.06, 1.08)
chains <- gen_chains(M, N, pareto_rdists)

rhat_infinity(chains, verbose = T)
```



```{r pareto_r_x2, warning=FALSE}
simulated_rhat <- all_local_rhat(chains, max_nb_points = "ALL")

plot_local_r(chains, simulated_rhat, theoretical_r_values,
             plot_legend = FALSE, col=c(colors[3], colors[2]),
             xlabels = xlabels, xlim = c(1,8), ylim=c(1,1.09), title ="")
```

The same observations as for the previous example can be done here: $\hat{R}_\infty$
overestimates $R_\infty$, whose value already allowed the diagnosis of a convergence issue.
We can verify the behaviour on replications: 

```{r pareto_hists, warning=FALSE}
r_functions <- c(trad_rhat, rhat, rhat_infinity)
r_names <- c("R-hat", "Rank-R-hat", "R-hat-infinity")
r_colors <- c(colors[4], colors[5], colors[3])

R_matrix_pareto <- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08)
plot_hist(R_matrix_pareto, colors = r_colors, xlabels = xlabels,
          plot_legend = FALSE, bin_size = 0.005, lim_y_axis = 500)
```

```{r, include=FALSE}
r_version <- c(r_version, 
               rep(colnames(R_matrix_pareto)[1], dim(R_matrix_pareto)[1]),
               rep(colnames(R_matrix_pareto)[2], dim(R_matrix_pareto)[1]),
               rep(colnames(R_matrix_pareto)[3], dim(R_matrix_pareto)[1]))  
r_experiment <- c(r_experiment, rep("2.Pareto", length(R_matrix_pareto)))
r_values <- c(r_values, as.vector(R_matrix_pareto))
```

## Counter examples for rank-$\hat{R}$

In this part, We will see 3 cases where rank-$\hat{R}$ doesn't manage to detect the convergence issue. 
These cases correspond to chains with different type of distributions, but with same mean and
mean over the median.

### Example (iii): Uniform and Laplace distributions

We start by an example where the population version can be computed explicitly: 
if one chain is uniformly distributed $\mathcal{U}(-2\sigma, 2\sigma)$ and 
another one from a Laplace distribution $\mathcal{L}(0, \sigma)$, where $\sigma>0$,
then calculations leads to $R_\infty \approx 1.018$, which means convergence issue.


```{r laplace_uniform_x, warning=FALSE}
sigma <- 1/4
M <- 2


dists <- c((function(q) punif(q, -2*sigma, 2*sigma)),
           (function(q) plaplace(q, mean = 0, sd = sqrt(2)*sigma)))


theoretical_r_values <- r_dist_values(npoints = 1000, xlim = c(-1.5, 1.5), 
                                      dists = dists)


rdists <- c((function(n) runif(n, -2*sigma, 2*sigma)),
            (function(n) rlaplace(n, mean = 0, sd = sqrt(2)*sigma)))


chains <- gen_chains(M, N, rdists)

rhat_infinity(chains, verbose = T)

```


```{r laplace_uniform_x2, warning=FALSE}
simulated_rhat <- all_local_rhat(chains, max_nb_points = "ALL")

xlabels <- c(1, 1.01, 1.02, 1.03)

plot_local_r(chains, simulated_rhat, theoretical_r_values, threshold = 1.01,
             xlabels = xlabels, col = c(colors[3], colors[2]),
             xlim = c(-1.5,1.5), ylim=c(1,1.03), title ="")

```

Replications show that rank-$\hat{R}$ is fooled in the same way as $\hat{R}$ in this
example:


```{r laplace_uniform_hists, warning=FALSE}

r_functions <- c(trad_rhat, rhat, rhat_infinity)
r_names <- c("R-hat", "Rank-R-hat", "R-hat-infinity")
r_colors <- c(colors[4], colors[5], colors[3])

R_matrix_lapl_unif <- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)

plot_hist(R_matrix_lapl_unif, colors = r_colors, bin_size = 0.003,
          xlabels = xlabels, plot_legend = TRUE, threshold = 1.01,
          lim_y_axis = reps, vaxis_pos = 0.9985)

```


```{r, include=FALSE}
r_version <- c(r_version, 
               rep(colnames(R_matrix_lapl_unif)[1], dim(R_matrix_lapl_unif)[1]),
               rep(colnames(R_matrix_lapl_unif)[2], dim(R_matrix_lapl_unif)[1]),
               rep(colnames(R_matrix_lapl_unif)[3], dim(R_matrix_lapl_unif)[1]))
r_experiment <- c(r_experiment, rep("5.Laplace/Uniform", length(R_matrix_lapl_unif)))
r_values <- c(r_values, as.vector(R_matrix_lapl_unif))
```

### Example (iv): Uniform and Normal distributions

Similarly, others distributions are possible to build counter-examples. 
Consider $m-1$ normal chains $\mathcal{N}\left(0, \frac{\pi}{2}\sigma^2\right)$ and
for the last one a uniform $\mathcal{U}(-2\sigma, 2\sigma)$:

```{r gaussian_uniform_x, warning=FALSE}
sigma <- 1/2
M <- 2

dists <- c((function(q) pnorm(q, mean = 0, sd = sqrt(0.5*pi)*sigma)),
           (function(q) punif(q, -2*sigma, 2*sigma)))

theoretical_r_values <- r_dist_values(npoints = 1000, xlim = c(-2, 2), 
                                      dists = dists)

rdists <- c((function(n) rnorm(n, mean = 0, sd = sqrt(0.5*pi)*sigma)),
            (function(n) runif(n, -2*sigma, 2*sigma)))

chains <- gen_chains(M, 2*N, rdists)

rhat_infinity(chains, verbose = T)

```

```{r gaussian_uniform_x2, warning=FALSE}


simulated_rhat <- all_local_rhat(chains, max_nb_points = "ALL")

xlabels <- c(1, 1.005, 1.01, 1.015, 1.02)

plot_local_r(chains, simulated_rhat, theoretical_r_values, 
             xlabels = xlabels, col=c(colors[3], colors[2]), threshold = 1.01,
             xlim = c(-2,2), ylim=c(0.999,1.025), title ="Gaussian/Uniform distributions")
```

Replications confirms that this construction are fooling the different versions
of $\hat{R}$ except $\hat{R}_\infty$.

```{r gaussian_uniform_hists, warning=FALSE}
r_functions <- c(trad_rhat, rhat, rhat_infinity)
r_names <- c("R-hat", "Rank-R-hat", "R-hat-infinity")
r_colors <- c(colors[4], colors[5], colors[3])

R_matrix_norm_unif <- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.01, 1.02, 1.03)
plot_hist(R_matrix_norm_unif, colors = r_colors, xlabels = xlabels,
          bin_size = 0.002, plot_legend = TRUE, threshold = 1.01,
          lim_y_axis = reps, vaxis_pos = 0.999)

```

```{r, include=FALSE}
r_version <- c(r_version, 
               rep(colnames(R_matrix_norm_unif)[1], dim(R_matrix_norm_unif)[1]),
               rep(colnames(R_matrix_norm_unif)[2], dim(R_matrix_norm_unif)[1]),
               rep(colnames(R_matrix_norm_unif)[3], dim(R_matrix_norm_unif)[1]))
r_experiment <- c(r_experiment, rep("4.Normal/Uniform", length(R_matrix_norm_unif)))
r_values <- c(r_values, as.vector(R_matrix_norm_unif))
```


### Example (v): Uniform and Exponential distributions

Finally, it is also possible to mix uniform distributions with exponential:

```{r exp_uniform_x, warning=FALSE}
M <- 4
N <- 200

min_unif <- 1-2*log(2)
max_unif <- 1+2*log(2)


dists <- c(rep(c((function(q) pexp(q))), M-1),
           (function(q) punif(q, min_unif, max_unif)))

theoretical_r_values <- r_dist_values(npoints = 500, xlim = c(-1, 6), 
                                      dists = dists)

rdists <- c((function(n) rexp(n)),
            (function(n) runif(n, min_unif, max_unif)))

chains <- gen_chains(M, N, rdists)
rhat_infinity(chains, verbose = T)

```

```{r exp_uniform_x2, warning=FALSE}


simulated_rhat <- all_local_rhat(chains, max_nb_points = "ALL")

xlabels <- c(1, 1.02, 1.04, 1.06, 1.08)
plot_local_r(chains, simulated_rhat, theoretical_r_values,
             xlabels = xlabels, col = c(colors[3], colors[2]),
             xlim = c(-1, 6), ylim=c(1,1.09), title ="")
```

```{r exp_uniform_hists, warning=FALSE}

r_functions <- c(trad_rhat, rhat, rhat_infinity)
r_names <- c("R-hat", "Rank-R-hat", "R-hat-infinity")
r_colors <- c(colors[4], colors[5], colors[3])

R_matrix_exp_unif <- repetitions_R(chains_func = (function() gen_chains(M, N, rdists)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

plot_hist(R_matrix_exp_unif, colors = r_colors, bin_size = 0.007, 
          lim_y_axis = 500, vaxis_pos = 0.997)
```

```{r, include=FALSE}
r_version <- c(r_version, 
               rep(colnames(R_matrix_exp_unif)[1], dim(R_matrix_exp_unif)[1]),
               rep(colnames(R_matrix_exp_unif)[2], dim(R_matrix_exp_unif)[1]),
               rep(colnames(R_matrix_exp_unif)[3], dim(R_matrix_exp_unif)[1]))
r_experiment <- c(r_experiment, rep("3.Exp/Uniform", length(R_matrix_exp_unif)))
r_values <- c(r_values, as.vector(R_matrix_exp_unif))
```


## Threshold estimation

In this part we focus on the case where all the distributions are the same, to 
verify the behavior in the null hypothesis.


```{r same_uniform_hists1, warning=FALSE}
M <- 2
N <- 200

colors_same <- c(rgb(0.55, 0, 0.4, 0.8), rgb(0.4, 0, 0.7, 0.8), rgb(0.5, 0, 0.5, 0.9))

R_matrix_same_unif <- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c("Uniform"),
                                    reps = reps)

R_matrix_same_par <- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c("Pareto"),
                                   reps = reps)

R_matrix_same_unif_par <- cbind(R_matrix_same_unif, R_matrix_same_par)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          threshold = 1.01001, xlabels = xlabels, bin_size = 0.0020, 
          lim_y_axis = 200, vaxis_pos = 0.9985, plot_legend = F)
```


```{r same_uniform_hists2, warning=FALSE}
M <- 4
N <- 100

R_matrix_same_unif <- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c("Uniform"),
                                    reps = reps)

R_matrix_same_par <- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c("Pareto"),
                                   reps = reps)

R_matrix_same_unif_par <- cbind(R_matrix_same_unif, R_matrix_same_par)


xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          xlabels = xlabels, bin_size = 0.002, threshold = 1.02,
          lim_y_axis = 200, vaxis_pos = 0.9985, plot_legend = F)
```


```{r same_uniform_hists3, warning=FALSE}
M <- 8
N <- 50

R_matrix_same_unif <- repetitions_R(chains_func = (function() gen_chains(M, N, uniform_rdists)),
                                    r_func = c(rhat_infinity),
                                    r_names = c("Uniform"),
                                    reps = reps)

R_matrix_same_par <- repetitions_R(chains_func = (function() gen_chains(M, N, pareto_rdists)),
                                   r_func = c(rhat_infinity),
                                   r_names = c("Pareto"),
                                   reps = reps)

R_matrix_same_unif_par <- cbind(R_matrix_same_unif, R_matrix_same_par)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04)
plot_hist(R_matrix_same_unif_par, colors = colors_same, plot_threshold = F,
          threshold = 1.03, xlabels = xlabels, bin_size = 0.002, 
          lim_y_axis = 200, vaxis_pos = 0.9985)
```


## Summary

```{r}
data=data.frame(r_version, r_experiment,  r_values)

ggplot(data, aes(x=r_experiment, y=r_values, fill=r_version)) +
    geom_boxplot() + 
    geom_hline(yintercept=1.01, linetype="dashed", 
               color = "black", size=0.5) +
    geom_hline(yintercept=1.02, linetype="dashed", 
             color = "green", size=0.5) +
    xlab("Experiments") + ylab("Values")
```





# Multivariate examples

In the multivariate case when $\boldsymbol{\theta}=(\theta_1, \ldots, \theta_d)\in{\mathbb R}^d$, 
we suggest to apply $\hat{R}$ on a multivariate indicator variable 
$I_{\boldsymbol{x}}^{(j)} = \mathbb{I}\{\theta_1^{(j)} \leq x_1, \ldots, \theta_d^{(j)} \leq x_d\}$ 
for any $\boldsymbol{x} = (x_1, \ldots, x_d) \in \mathbb{R}^d$ in two steps:

\begin{enumerate}
    \item Compute the univariate $\hat{R}_{\infty,p}$ separately on each of the 
    coordinates $p\in\{1,\dots,d\}$.
    \item If $\hat{R}_{\infty,p} < 1.01$ for all $p\in\{1,\dots,d\}$, then all 
    margins are deemed to have converged and to be identically distributed.
    Compute the multivariate $\hat{R}_\infty$ to check the convergence of the 
    dependence structure.
\end{enumerate}

Thus we recommend to compute the multivariate version only in the case where all the
univariate one doesn't detect any convergence issue, this is why in the part we will
focus only of cases where the margins are the same (for example uniform).


```{r, comment=NA, message=FALSE, warning=FALSE, results='hide', cache=FALSE}
library("MASS") # For Multivariate Normal Distribution
library("stableGR") # For the R-hat version of Vats and Knudson (2018)
library("coda") # For an implementation of the multivariate R-hat of Brooks and Gelman (1998)
library("rWishart") # Wishart distribution
library("mcmc") # for logit data
library("ggridges")


brooks_multivariate_rhat <- function(chaines){
  R_star_chains = aperm(chaines, c(1, 3, 2))
  return (r_hat_multivariate(R_star_chains, split_chains = F))
}

coda_multivariate_rhat <- function(chaines){
  chaines_list = list()
  for (i in 1:dim(chaines)[3]){
    mcmc_ch <- as.mcmc(chaines[,,i])
    chaines_list[[i]] <- as.mcmc(chaines[,,i])
  }
  mcmc_chains = do.call(mcmc.list, list(chaines_list))
  return (gelman.diag(mcmc_chains)$mpsrf)
}

```


## Bivariate Case: Normal distributions

In this section, we focus on two-dimensional parameters on which we aim at 
diagnose convergence of the corresponding MCMC (with any number of chains).
This restriction allows to navigate easily between the positive dependence 
and the negative one of the two components.

In particular, we consider bivariate normal densities with zero means, and compare 
$m-1$ chains with identity covariance matrix, and one with non-zero off-diagonal
elements $\rho \in (-1,1)$.

We start by define the function that will allows us to generate $m$ chains of 
size $n$ with this configuration :

```{r, warning=FALSE}
gen_bvnormal_chains <- function(M, N, rho){
  sig_matrix <- (1-rho) * diag(2) + matrix(rho, nrow=2, ncol=2)
  return (array(c(mvrnorm((M-1)*N, mu = rep(0, 2), Sigma = diag(2)), 
                  mvrnorm(N, mu = rep(0, 2), Sigma = sig_matrix)), c(N,2,M)))
}
```


As an example, we consider the case with $m=2$ chains of size $n=100$, and 
$\rho = 0.9$ on the last chain. 
This choice of $n$ relatively small is due to the fact the elements in the chain
are i.i.d here, so $n$ can be seen as an effective sample size for a given chain
here.

```{r bivariate_hists, warning=FALSE}
rho <- 0.9
M <- 2
N <- 200

chains <- gen_bvnormal_chains(M, N, rho)
rhat_infinity(chains, verbose = T)
```

We simulate 100 experiments, which result as 100 draws of the different $\hat{R}$.

Histogram of the corresponding values of $\hat{R}_\infty$ and the multivariate
$\hat{R}$ of Brooks and Gelman (1998) :

```{r bivariate_hists2, warning=FALSE}
rho <- 0.9
M <- 2
N <- 200
reps <- 100

r_functions = c(brooks_multivariate_rhat, rhat_infinity)
r_names = c("Brooks Multivariate R-hat", "R-hat-infinity")
r_colors = c(colors[4], colors[3])

R_matrix = repetitions_R(chains_func = (function() gen_bvnormal_chains(M, N, rho)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08, 1.1, 1.12)
plot_hist(R_matrix, colors = r_colors, bin_size = 0.0045, 
          lim_y_axis = 30, vaxis_pos = 0.995,
          xlabels = xlabels, plot_threshold = F)
```



### Evolution of the different value of $\hat{R}$ with $\rho$

Except for $R^*$, we consider the mean of the 100 draws for the different 
versions of $\hat{R}$, and plot the evolution of this value with $\rho$:

```{r bivariate_rho, warning=FALSE}

rho_list = c(-0.99, -0.9, -0.7, -0.5, -0.2, 0, 0.2, 0.5, 0.7, 0.9, 0.99)

d <- 2
M <- 2
N <- 500
reps <- 10


r_functions <- c(rhat_infinity, brooks_multivariate_rhat)
r_names <- c("R-hat-infinity", "Brooks R-hat")

R_values <- c()
x_val <- c()
theoretical_R <- c()


for (rho in rho_list){
  R_val_rho = repetitions_R(chains_func = (function() gen_bvnormal_chains(M, N, rho)), 
                                    r_func = r_functions, 
                                    r_names = r_names, 
                                    reps = reps)
  R_values = rbind(R_values, R_val_rho)
  x_val = c(x_val, rep(rho, reps))
  
  sig_matrix <- (1-rho) * diag(2) + matrix(rho, nrow=2, ncol=2)
  dists <- c((function(q) mvtnorm::pmvnorm(upper = q, sigma = diag(2))[1]),
             (function(q) mvtnorm::pmvnorm(upper = q, sigma = sig_matrix)[1]))
  theoretical_R = c(theoretical_R, max_r_dist_bivariate(npoints = 200, 
                                                        xlim = c(-3,3), 
                                                        dists = dists))
}

par(mar=c(4,5.5,2,2))
plot(x=x_val, y=R_values[,1],
     col = c(colors[3]), pch = 19,
     xlab = expression(rho["m"]), ylab = "",
     xaxs="i", yaxs="i", bty = "n",
     xaxt = "n", yaxt = "n",
     cex.lab = 2, cex.main = 2,
     lwd=9,
     xlim = c(-1.01, 1.02), ylim = c(0.999,1.155))
points(x=x_val, y=R_values[,2], 
       col = c(colors[4]), pch = 19,
       lwd=9)
lines(rho_list, theoretical_R, type="l", col = colors[2], lwd=6, lty = 2)
points(x=rho_list, y=theoretical_R, 
       col = c(colors[2]), pch = 19,
       lwd=9)
xlabels = c(1, 1.03, 1.06, 1.09, 1.12, 1.15)
ylabels = c(-1, -0.5, 0, 0.5, 1)
axis(1, labels=ylabels, at=ylabels, cex.axis=2, lwd=3, mgp = c(1,1,0))
axis(2, labels=xlabels, at=xlabels, cex.axis=2, mgp = c(1,0.5,0), lwd=2)
legend(x=0.6, y=1.14, col=c(colors[4], colors[3], colors[2]), pch=19, 
       legend = c(expression(italic(hat(R))),
                  expression(italic(hat(R)[infinity])),
                  expression(italic(R[infinity]))), cex=2)
```

Remarks : 

- Our version is the most sensitive, and is more sensitive as $|\rho|$ increases
(which is great)
- The asymmetry can be link to the theoretical computations.
WARNING: in the case where $d=2$, the orders on the two bounds PQD and NQD are 
inverted (compared to the asymptotic behavior), and that is why here we are 
more sensitive when $\rho < 0$ (which is counter-intuitive)


## General number of dimensions

### Generation of a covariance matrix

In the general case, we still compare $m-1$ chains that follows a multivariate
normal distribution with identity covariance matrix with one that has a given 
covariance matrix $\Sigma$. 

We generate $\Sigma$ from a sample of a Wishart distribtution $S$, and in order 
to keep the same margins for our chains, we transform $S$ to have ones on the
diagonal :
$$
\Sigma = D^{-1/2} S D^{-1/2}, 
\quad \text{ with } \quad 
D = \text{Diag}\left(s_{1,1}, \ldots, s_{d,d}\right)
$$

From the theoretical part, we know that the value given by $\hat{R}_\infty$ 
depends on the direction of dependence.
Thus, we can either fix $\Sigma$ and study the behaviour of the different 
$\hat{R}$, or sample a new $\Sigma$ for each draw of $\hat{R}$.

```{r, warning=FALSE}

generate_sigma_matrix <- function(d){
  S <- rWishart(1, d, diag(d))[,,1]
  S <- diag(1/sqrt(diag(S))) %*% S %*% diag(1/sqrt(diag(S)))
  return (S)
}

gen_mvnormal_chains <- function(M, N, d, S=NULL){
  if (is.null(S)){
    S <- generate_sigma_matrix(d)
  }
  return (array(c(mvrnorm((M-1)*N, mu = rep(0, d), Sigma = diag(d)), 
                  mvrnorm(N, mu = rep(0, d), Sigma = S)), 
                c(N,d,M)))
}

```

First, we start by considering $d=5$ and study the behavior of $\hat{R}_\infty$
and the multivariate $\hat{R}$ of Brooks and Gelman (1998) on a given $\Sigma$
for the last chain:

```{r multivariate_hist1, warning=FALSE}

d <- 5

M <- 4
N <- 100
reps <- 100

r_functions <- c(brooks_multivariate_rhat, rhat_infinity)
r_names <- c("Brooks Multivariate R-hat", "R-hat-infinity")
r_colors <- c(colors[3], colors[4])

S <- generate_sigma_matrix(d)
print(S)

R_matrix <- repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d, S)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

plot_hist(R_matrix, colors = r_colors, bin_size = 0.002, 
          lim_y_axis = 25, vaxis_pos = 1,
          plot_threshold = F)

```

Doing the same experiment but with a new $\Sigma$ on each repetitions will
result on a histogram more spread for $\hat{R}_\infty$:

```{r multivariate_hist2, warning=FALSE}


d <- 5

M <- 4
N <- 100
reps <- 100

r_functions <- c(brooks_multivariate_rhat, rhat_infinity)
r_names <- c("Brooks Multivariate R-hat", "R-hat-infinity")
r_colors <- c(colors[3], colors[4])

R_matrix <- repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d)), 
                         r_func = r_functions, 
                         r_names = r_names, 
                         reps = reps)

xlabels = c(1, 1.02, 1.04, 1.06, 1.08)
plot_hist(R_matrix, colors = r_colors, 
          xlabels = xlabels, bin_size = 0.002, 
          lim_y_axis = 20, vaxis_pos = 0.997,
          plot_threshold = F)

```

To avoid this issue, $\hat{R}_\infty$ can be computed on all directions, 
which means if $d=3$ that $\hat{R}$ is computed on 
$$
  I\left(\theta_1^{(n,m)} \leq x_1, \theta_2^{(n,m)} \leq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \geq x_1, \theta_2^{(n,m)} \leq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \leq x_1, \theta_2^{(n,m)} \geq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
  I\left(\theta_1^{(n,m)} \geq x_1, \theta_2^{(n,m)} \geq x_2, \theta_3^{(n,m)} \leq x_3\right)\\
$$
The other half of the possibilities is avoided by symmetry. 
Then, we can define $\hat{R}^{(\text{max})}_\infty$ as the maximum of all the 
$\hat{R}_\infty$ computed on all directions.
Despite a unreasonable computational cost (with $2^{d-1}$ $\hat{R}_\infty$ 
to compute), this solutions seems satisfying in small dimension:

```{r r_dimensions, warning=FALSE}

d_max = 6

M = 4
N = 100
reps = 200


r_functions = c(rhat_infinity, rhat_infinity_max_directions)
r_names = c("One Direction", "All Directions")

R_values = repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, 2)),
                         r_func = r_functions,
                         r_names = r_names,
                         reps = reps)


R_array = array(c(R_values[,1], rep("d = 2", reps), rep("1 Dir", reps)), dim = c(reps,3))
R_array = rbind(R_array, array(c(R_values[,2], rep("d = 2", reps), rep("All Dir", reps)), dim = c(reps,3)))
colnames(R_array) = c("Values", "Dim", "Nb_Dir")

for (d in 3:d_max){
  R_val_d = repetitions_R(chains_func = (function() gen_mvnormal_chains(M, N, d)),
                             r_func = r_functions,
                             r_names = r_names,
                             reps = reps)
  d_names = c(paste("d =", d))
  R_array = rbind(R_array, array(c(R_val_d[,1], rep(d_names, reps), rep("1 Dir", reps)), dim = c(reps,3)))
  R_array = rbind(R_array, array(c(R_val_d[,2], rep(d_names, reps), rep("All Dir", reps)), dim = c(reps,3)))

}

R_df = as.data.frame(R_array)
R_df$Values = as.numeric(R_df$Values)

# pdf(file = "/scratch/tmoins/Documents/Code_rhat/figure_article/hist_directions.pdf", width = 18, height = 8)
ggplot(R_df, aes(x = Values, y = as.factor(Dim), fill = Nb_Dir)) +
  geom_density_ridges(stat = "binline", bins= 40,
                      scale = 1, alpha = 0.7) +
  scale_y_discrete(limits = R_df$Dim) +
  ylab("Dimensions") + labs(fill = element_blank()) +
  scale_x_continuous(limits = c(1,1.14),
                     n.breaks = 8) +
  scale_fill_manual(values=c("#32a632", "#4287f5")) +
  theme_ridges(font_size=22)
# dev.off()

```

(WARNING: $d>6$ the chunk is very dangerous to run!!)

## Logistic regression

As a practical bayesian example, we consider hierarchical logistic regression using 
the following model:

```{r, warning=FALSE}
writeLines(readLines(paste(stan_folder, "logit_reg.stan", sep="")))
```

We run Stan using the dataset \texttt{logit} available in the package \texttt{mcmc}.

```{r, warning=FALSE}
data("logit")
d <- 4
logit_data<- read_rdump(paste(stan_folder, "logit_reg.data.R", sep=""))
fit_logit <- stan(file = paste(stan_folder, "logit_reg.stan", sep=""),
                  data=logit_data, seed = 12,
                  iter=200, chains=4, refresh=0)
mon <- monitor(fit_logit)

chains <- as.array(fit_logit)
dim_chains <- dim(chains)

rhat_inf <- c()

for (i in 1:dim_chains[3]) {
  chains_i <- chains[, , i]
  rhat_inf_i <- rhat_infinity(chains_i, max_nb_points = "ALL")
  rhat_inf <- c(rhat_inf, rhat_inf_i)
}

mon[["Rhat_inf"]] <- rhat_inf

mon
summary(mon[1:d, 'Rhat'])
summary(mon[1:d, 'Rhat_inf'])

mon[d+1, "Rhat_inf"]

perm_chains <- aperm(chains, c(1,3,2))
rhat_infinity_max_directions(perm_chains)
```

```{r, warning=FALSE}
reps <- 50

gen_beta_logit <- function(i){
  # fit_logit <- stan(file = paste(stan_folder, "logit_reg.stan", sep=""),
                    # data=logit_data,
                    # iter=200, chains=4, refresh=0)
  # saveRDS(fit_logit, paste(stan_folder, "logit/logit_reg_", i, ".rds", sep=""))
  fit_logit <- readRDS(paste(stan_folder, "logit/logit_reg_", i, ".rds", sep=""))
  mon <- monitor(fit_logit)
  
  chains <- as.array(fit_logit)
  
  return (aperm(chains, c(1,3,2)))
}

r_functions = c(brooks_multivariate_rhat, rhat_infinity_max_directions)
r_names = c("Brooks Multivariate R-hat", "max-R-hat")
r_colors = c(colors[4], colors[2])

R_matrix_logit <- repetitions_R(chains_func = gen_beta_logit, 
                                 r_func = r_functions, 
                                 r_names = r_names, 
                                 reps = reps, saved_model = TRUE)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04, 1.05)
plot_hist(R_matrix_logit, colors = r_colors, xlabels = xlabels,
          vaxis_pos = 0.998, plot_threshold = F, threshold = 1.03,
          bin_size = 0.003, lim_y_axis = 25)
```


```{r, warning=FALSE}

gen_beta_logit_lp <- function(i){
  fit_logit <- readRDS(paste(stan_folder, "logit/logit_reg_", i, ".rds", sep=""))
  mon <- monitor(fit_logit)
  chains <- as.array(fit_logit)
  return (chains[, , 5])
}

r_functions <- c(trad_rhat, rhat, rhat_infinity)
r_names <- c("R-hat",
             "Rank-R-hat",
             "R-hat-infinity")
r_colors <- c(colors[4], colors[5], colors[3])

R_matrix_logit2 <- repetitions_R(chains_func = gen_beta_logit_lp, 
                                 r_func = r_functions, 
                                 r_names = r_names, 
                                 reps = reps, saved_model = TRUE)

xlabels = c(1, 1.01, 1.02, 1.03, 1.04, 1.05)
plot_hist(R_matrix_logit2, colors = r_colors, vaxis_pos = 0.998,
          xlabels = xlabels, plot_threshold = T,
          bin_size = 0.003, lim_y_axis = 25)
```


